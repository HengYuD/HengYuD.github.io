<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gr_bokeh_env]]></title>
    <url>%2Fgr-bokeh-env%2F</url>
    <content type="text"><![CDATA[前阵子在弄的一个小项目，记录一下环境 环境ubuntu16.04gnuradio v3.7.13.5(最新版) gnuradio安装参考) NodeJS v6.16.0(最好在6.10.0之后的版本) 1234567# wget https://nodejs.org/download/release/v6.16.0/node-v6.16.0-linux-x86.tar.xz # tar xf node-v6.16.0-linux-x86.tar.xz # cd node-v10.9.0-linux-x64/ # ./bin/node -v ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/ pip install sudo apt-get install python-pip python -m pip install –upgrade pip pip v19.1.1(/usr/bin/pip) 1234import sysfrom pip import __main__if __name__ == &apos;__main__&apos;: sys.exit(__main__._main()) pip换源 12345678pip install -i https://pypi.tuna.tsinghua.edu.cn/simple或者linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改index-url至tuna，内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simplewindows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple tornado v4.4Jinja2 v2.8python-dateutil v2.8.0PyYAML v5.1.1numpy v1.16.4pandas v0.24.2packaging v19.0six v1.12.0bokeh v0.12.9(之后的版本移除了resize)apt install apt换源 123456789101112sudo vim /etc/apt/sources.list#deb包deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse apache2php7.0mysql （mysql-server mysql-client）libapache2-mod-php7.0php7.0-mysql makegr-bokehgui]]></content>
      <categories>
        <category>GnuRadio</category>
      </categories>
      <tags>
        <tag>gr-bokeh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql注入平台搭建及相关测试]]></title>
    <url>%2Fmysql%E6%B3%A8%E5%85%A5%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[实验目的研究 SQL 注入的原理， 通过搭建具有 SQL 注入的服务器的环境， 分别用Sqlmap 和手工注入的方式， 结合 WireShark 抓包分析， 进一步理解 SQL 注入的本质； 本实验通过在服务端部署具有 SQL 注入漏洞的 PHP 脚本，在 Ubuntu 系统上采用 Firefox浏览器的 url 执行手工注入， 而采用 Sqlmap 执行自动化注入； 采用不同的防注入手段， 再尝试 Sqlmap 注入， 观察结果 实验环境ubuntu16.04、apache2、mysql、php7、sqlmap、 实验步骤1234567891011sudo apt-get install apache2#sudo service apache2 status/start/stop/restartsudo apt-get install mysql-server mysql-client#sudo apt-get install status/start/stop/restart#sudo netstat -tapsudo apt-get install php7.0#php7.0 -vsudo apt-get install libapache2-mod-php7.0sudo apt-get install php7.0-mysqlsudo service apache2 restartsudo service mysql restart ​ 搭建 mysql 数据库，建立数据库 test，数据表 student，包含 id、name、score 三列 ​ mysql -u root -p test ​ 编写有 sql 注入漏洞接口程序的php文件，放入/var/www/html/目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpif(isset($_GET['op'])) &#123; if (mysqli_connect_errno($con)) &#123; echo "连接 MySQL 失败: " . mysqli_connect_error(); &#125; $sql = mysqli_connect('localhost', 'root', '65412345','test'); if($sql) &#123; $op = $_GET['op']; switch($op) &#123; case 1: //输入学号显示姓名和分数 $id = $_GET['id']; $res = mysqli_query($sql,"select * from student where id = '$id';"); while($row = mysqli_fetch_array($res)) &#123; echo 'name： '.$row['name'].'&lt;br/&gt;'; echo 'score： '.$row['score']; &#125; break; case 2: //输入学号展示学生是否存在 $id = $_GET['id']; $res = mysqli_query($sql,"select * from student where id = '$id';"); $row = mysqli_fetch_array($res); if($row) &#123; echo 'exist'; &#125; else &#123; echo 'not exist'; &#125; break; case 3: //将查询结果是否为空展示在两段随机内容之间 $id = $_GET['id']; $res = mysqli_query($sql,"select * from student where id = '$id';"); $row = mysqli_fetch_array($res); if($row) &#123; echo rand().'exist'.rand(); &#125; else &#123; echo rand().'not exist'.rand(); &#125; break; case 4: //输入学号， 查询成绩是否大于 60， 结果展示在两段随机内容之间 $id = $_GET['id']; $res = mysqli_query($sql,"select * from student where id = '$id';"); $row = mysqli_fetch_array($res); if($row) &#123; $res = mysqli_query($sql,"select * from student where id = '$id' and score &gt; 60;"); $row = mysqli_fetch_array($res); if($row) &#123; echo rand().'(score &gt; 60)'.rand(); &#125; else &#123; echo rand().'(score &lt;= 60)'.rand(); &#125; &#125; else &#123; echo rand().'not exist'.rand(); &#125; break; case 5: //输入学号展示学生是否存在， 但输出固定内容 $id = $_GET['id']; $res = mysqli_query($sql,"select * from student where id = '$id';"); $row = mysqli_fetch_array($res); if($row) &#123; echo 'query ok'; &#125; else &#123; echo 'query ok'; &#125; break; case 6: //输入学号和分数， 更新对应学生的分数 $id = $_GET['id']; $score = $_GET['score']; if(mysqli_query($sql,"update student set score ='$score' where id = '$id';")) &#123; echo 'update ok'; &#125; else &#123; echo 'updata fail'; &#125; break; default: break; &#125; &#125; else &#123; die("connect error: " . mysqli_connect_error()); &#125; mysqli_close($sql); &#125;?&gt; 功能实现并手工注入输入的学号展示姓名和分数（op=1） 布尔盲注?op=1&amp;id=1’or’1’=’1 构成 select * from student where id = ‘1’ or ‘1’ = ‘1’ 联合注入?op=1&amp;id=111’ union all select table_schema,table_name,table_schema from information_schema.tables where ‘1’ = ‘1 可以爆出了所有的数据库， 以及数据库下对应的表 也可以选择已知的数据库名和表明来构造 ?op=1&amp;id=111’ union all select column_name,data_type,column_name from information_schema.columns where table_schema = ‘test’ and table_name = ‘student 输入学号，展示是否有该学生存在（op=2） 可以通过返回结果的不同遍历出存在的值或者数据库，也可以改变sql查询的语义来查询其它数据库中各项的值 将查询结果是否为空展示在两段随机内容之间（op=3） ​ 发现在结果前后添加任意长的随机字符与不增加随机字符相比在本质上并没有安全，只是使得攻击脚本增加提取字符串的步骤，提高了爆破的时间成本。 展示查询结果的条件表达式结果，将结果展示在两段随机内容之间（op=4） 如入学号，展示该学生分数是否大于 60。 查看源码 123456789101112131415$id = $_GET[&apos;id&apos;]; $res = mysqli_query($sql,&quot;select * from student where id = &apos;$id&apos;;&quot;); $row = mysqli_fetch_array($res); if($row) &#123; $res = mysqli_query($sql,&quot;select * from student where id = &apos;$id&apos; and score &gt; 60;&quot;); $row = mysqli_fetch_array($res); if($row) &#123; echo rand().&apos;(score &gt; 60)&apos;.rand(); &#125; else &#123; echo rand().&apos;(score &lt;= 60)&apos;.rand(); &#125; &#125; else &#123; echo rand().&apos;not exist&apos;.rand(); &#125; break; ​ 首先要保证 id 在数据库中存在的才能绕过第一个 SQL 查询语句，利用第二个查询语句回显的不同结果来猜测字段的值。第二个语句中的 and score &gt; 60 给注入增加了麻烦， 若联合查询查询其它表中的信息，会因为没有 score 字段而无法让反馈信息按照我们想要的方式展现，可以将目标 SQL 语句夹在多个 union all 中间来绕过限制。 根据输入的参数值，拼接 SQL 查询语句并执行，但展示一个固定的结果（op=5） 如输入学号查询学生是否存在，输出固定内容 此接口的设计， 适用不需要回显查询结果的场景，这种场景下，利用查询结果的回显来猜测字段的值的方法不适用，可以采用延时注入的方法。将 sleep(5)加入到 union all 后边的 select 语句的 where 条件部分， 当数值猜测正确， 浏览器会多加载 5s 的时间， 根据页面加载时间来判断表项数值的猜测是否正确。即通过添加条件判断到SQL中，比如IF(substring(version(),1,1)=5, sleep(5), ‘t’) AS value就能做到类似boolean注入的效果。 可以用F12里面的 Network 来查看加载时间 更新数据库（op=6） 如输入学号和分数，将对应学生的分数更新。 这是对于 update 语句的注入， 常用基于报错、 基于时间延迟这两种注入方法。 采取基于报错的 SQL 注入， 发现并未有报错显示， 猜测报错被关闭， 所以， 我们可以采用基于时间延迟的注入。 先猜测当前数据库名称的长度，–+是 MySQL 中的单行注释符号，用于注释掉后边的单引号，也可以采用%23， 转义后为#， 也同样起到注释的作用?op=6&amp;score=100&amp;id=111’ and if(length(database())=4,sleep(5),1) –+ 用 sqlmap 尝试各种注入方式并用 wireshark 抓包，记录每次的目标、SQL 命令行、结果（包括出结果的过程、和最终的输出）、和抓包文件op=1sqlmap -u “http://127.0.0.1/sql_test.php?op=1&amp;id=11110000001&quot; -D test –flush-session op=1&amp;id=11110000001%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285%29%29%29fdoA%29%20AND%20%27EnPH%27%3D%27EnPH op=1&amp;id=11110000001&#39; AND (SELECT * FROM (SELECT(SLEEP(5)))fdoA) AND &#39;EnPH&#39;=&#39;EnPH op=2sqlmap -u “http://127.0.0.1/sql_test.php?op=2&amp;id=11110000001&quot; -D test –flush-session op=2&amp;id=11110000001%27%20AND%206489%3D6489%20AND%20%27QACF%27%3D%27QACF op=2&amp;id=11110000001&#39; AND 6489=6489 AND &#39;QACF&#39;=&#39;QACF op=3sqlmap -u “http://127.0.0.1/sql_test.php?op=3&amp;id=11110000001&quot; -D test –flush-session 随机内容对工具起了作用， 其动态的干扰让工具无法基于 YES or NO 两种情 况来 判 断是否存在 Boolean-based blind ， 而实际上SQL 注入漏洞是存在的 op=3&amp;id=11110000111%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285%29%29%29sKzT%29%20AND%20%27oBjS%27%3D%27oBjS op=3&amp;id=11110000111&#39; AND (SELECT * FROM (SELECT(SLEEP(5)))sKzT) AND &#39;oBjS&#39;=&#39;oBjS op=4sqlmap -u “http://127.0.0.1/sql_test.php?op=4&amp;id=11110000001&quot; -D test –flush-session –dbms=MySQL 之所以没有扫描出注入点， 一是输出的随机内容的干扰， 二是条件查询语句中的 score &gt;60 工具的基本框架中， 没有像前方手工注入那样构造出多个 union all 组合的灵活语句来处理 score &gt; 60 这个特定的问题。需要手动推理和分析后台可能的 SQL 句式 op=5sqlmap -u “http://127.0.0.1/sql_test.php?op=5&amp;id=11110000001&quot; -D test –flush-session –dbms=MySQL op=5&amp;id=11110000111%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285%29%29%29TwTX%29%20AND%20%27Ztqw%27%3D%27Ztqw op=5&amp;id=11110000111&#39; AND (SELECT * FROM (SELECT(SLEEP(5)))TwTX) AND &#39;Ztqw&#39;=&#39;Ztqw op=6sqlmap -u “http://127.0.0.1/sql_test.php?op=6&amp;id=11110000001&amp;score=66&quot; -D test –flush-session op=6&amp;id=11110000001%27%20AND%20%28SELECT%20%2A%20FROM%20%28SELECT%28SLEEP%285%29%29%29msbv%29%20AND%20%27lJma%27%3D%27lJma&amp;score=66 op=6&amp;id=11110000001&#39; AND (SELECT * FROM (SELECT(SLEEP(5)))msbv) AND &#39;lJma&#39;=&#39;lJma&amp;score=66 SQL注入的防御SQL注入漏洞的一般性防范措施是预编译SQL查询语句，让查询语句参数化，秉持着用户输入的数据与代码相分离的原则。当然，对于数据库的操作权限进行严格的控制，对关键字符的过滤以及增加随机化参数等措施都能够在一定程度上对sql注入进行防御。]]></content>
      <tags>
        <tag>MySQL注入实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络设备性能测试]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[实验目的利用实验室现有待测设备（华为S5720-52P-EI-AC三层交换机）、测试设备（信尔泰BigTao220网络测试仪）以及控制计算机，构建简单的测试环境，通过Renix测试软件对待测设备端口转发延迟、端口丢包率、端口吞吐量以及拥塞控制机制进行交换机设备的性能测试 实验环境华为 S5720-52P-EI-AC 三层交换机信尔泰 BigTao220 网络测试仪、Renix 测试软件 、 实验基本原理及步骤以太网交换机的工作原理1、若地址表显示目的节点与源节点位于交换机的同一端口，则忽略帧2、若地址表显示目的节点在交换机所连的某一端口，且与源节点不在同一端口，则转发帧到目的端口3、若目的 MAC 地址为广播地址，则向除源端口外的所有端口转发帧4、若地址表中找不到目的地址，则向除源端口外的所有端口转发帧 数据传输层面相关指标1、负载2、转发速率(在某个特定负载下，一台网络设备在单位时间内向目标端口成功转发的帧数)3、丢帧率4、吞吐量（在没有出现丢帧的条件下，能够传输给交换机让其转发到指定输出端口的每秒最大帧数）5、突发 传输控制层面相关指标1、拥塞控制：是指在以太网上控制源端发送数据的数量及速度使其不超过接收端所能承受的能力，以避免产生帧的丢失2、地址处理3、错误帧过滤4、广播5、流量隔离 两种典型的以太网拥塞控制机制背压背压较常见（凡事当外出或输出端口出现拥塞现象时，被交换机用来通知发送端降低帧发送速度，以阻止外部数据继续向拥塞端口传输帧的那些方法，均属于背压。常见的背压方法包括向流发送源回送拥塞信号，向流发送源回送前导位串，或采用 IEEE802.2x 流量控制协议等。）前压它们可以通过诸如减缓输出队列的饱和程度和禁止上游设备发送帧等强制机制来消除或减少上述丢帧现象。 地址学习在测试开始之前让被测试交换机学习测试中将要用到的 MAC 地址。因为任何地址未被学习的帧都会被 DUT 作为泛洪帧转发，从而减少了测试过程中被正确转发帧的数量。 吞吐量测试1、吞吐量是单位时间内成功地传送数据的数量2、测试目的是找到在没有丢包的情况下端口能够转发的最大速率3、测试要点： A、被测设备的整体转发能力即整机吞吐量。 B、被测设备对某种单一应用的支持程度即端口吞吐量。 C、最常用吞吐量搜索算法是二分搜索法 吞吐量测量方法步进发：定义初始负载 Load0 和一个步进长度 Load,若初始负载下的丢帧率为零，以步长进行负载递增，一旦首次观测到丢失帧就停止对 Load 步进，并将该负载下的转发速率作为所要查找的吞吐量。二分迭代：定义最小负载 Load_Min、最大负载 Load_Max、初始负载 Load0 和迭代分辨率。若在某负载时，观测到有丢帧，则将当前负载 Load-&gt;Load-(Load-Load_Min)/2 再进行查找；若在某负载时，没有观测到丢帧，则将当前负载 Load-&gt;Load+(Load_Max-Load)/2 再进行查找 丢包率测试1、目的是确定 DUT 在不同的负载和帧长度条件下的丢包率。2、测试方法 A、一对端口发送和接收（DUT 一个端口接收到的数据经另一个端口转发） B、部分网状多对一端口测试（DUT 多个端口接收到的数据都由一个端口转发） C、多对多全网状测试（DUT 每一个端口接收到的数据都要送给其余任意一个端口）3、 丢包率公式（丢包率与吞吐量关系） （（发送包数量 X-接收包数量 Y） *100） /发送包数量 Y 拥塞控制功能的测试方法1、测试拓扑设计：由 DUT 上的 4 个端口组成一个测试块，要求这 4 个端口必须具有相同的 MOL。其中两个端口作为源发送端口，两个作为目标接受端口。2、配置两个接收端口分别配置为拥塞端口和非拥塞端口。3、设置测试参数4、统计测试结果5、根据测试结果判断。 根据拥塞端口和非拥塞端口的丢失率和转发速率来判断 DUT 是否执行了拥塞控制。 若拥塞端口丢帧率为0，表明在 DUT 内有背压机制。因为背压机制的存在，阻止了外部数据源向拥塞的端口传输帧，减缓了输出端口的拥塞，并因此避免了帧的丢失。 若非拥塞端口丢帧率为 0，转发速率低于 50%，那么 DUT 上执行了拥塞控制。因为拥塞控制机制在减缓外部数据源向拥塞端口传输帧的同时，也造成了非拥塞端口吞吐量下降。 若非拥塞端口丢帧率不等于零，则表明 DUT 中出现了列头阻塞。线端阻塞通常会发生在才用了队列 DUT 上。由于输入队列头有转发到拥塞端口的帧，而 DUT 不能将这些帧及时转发到拥塞端口，结果造成队列中后继转发到非拥塞端口的帧必须等待，导致非拥塞端口的帧丢失。 实验数据记录端口转发延迟、丢包率和吞吐量这三个指标应选择不少于两种包长进行测试，每轮测试时间不少于30s 。根据RFC2889，我们的延迟、丢包率、吞吐量每个不同包长测 20 次。 测试结果根据我们的测试，包长越长延迟越高，吞吐量的大小与包长没有联系，拥塞端口丢帧率不为 0，所以被测设备没有或未开启背压机制，由于非拥塞端口丢帧率等于 0，所以被测设备未出现列头阻塞]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>设备测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow-神经网络初始]]></title>
    <url>%2FTensorFlow-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[TensorFlow 编程基础TensorFlow中的张量概念 TensorFlow用张量这种数据结构来表示所有的数据，可以把一个张量想象成一个n维的数组，一个张量有一个静态类型和动态类型的维数，张量可以在图中的节点之间流通，张量没有真正保存数字，它保存的是计算过程 变量、常量和占位符区别 常量不能改变，不需要进行初始化操作；变量在运行过程中值会改变，须进行初始化操作创建语句，增加了一个init初始化变量，并调用绘画的run命令对参数进行初始化；占位符不包含任何数据，因此不需要初始化，是TensorFlow中特有的一种数据结构，类似动态变量，函数的参数、或者C语言或者Pyrhon语言中格式化输出时的 ”%”。 总结变量初始化方式个别变量初始化 init_op = name_variable.initializer() 所有变量初始化 init_op = tf.global_variables_initializer() 若一个变量的初始化依赖于其他变量的初始化，为了确保初始化顺序不能错，可以使用initialized_value() TensorBoard使用方法在python程序末尾确定输出的日志文件log位置 12345logdir='C:/Users/xxx/Desktop/log'writer = tf.summary.FileWriter(logdir,tf.get_default_graph())writer.close() 这里需要注意的是目录的路径中不能使用 “\“ ，可能会导致一些不能解析的错误 命令行进入日志存放目录中执行 tensorboard –logdir=/path/log 然后浏览器进入http://localhost:6006/ 即可 单变量线性回归形如y = w * x + b 给出一堆 x，和对应的标签 y，给出一个新的 x，希望算出来对应的 y；这种一次线性的模型，需要做的就是确定相关的 w、b 参数，模型内部的参数值是通过学习得到的 使用Tensorflow解决单变量线性回归问题的主要步骤 生成人工数据集及其可视化 构建线性模型 定义损失函数 定义优化器、最小化损失函数 训练结果的可视化 利用学习到的模型进行预测 多元线性回归多元线性回归中的模型训练方法 设置训练超参数 定义均方差损失函数 选择优化器 声明会话 启动会话 迭代训练 如何对特征数据进行归一化处理 （特征值-特征值最小值）/（特征值最大值-特征值最小值） 卷积神经网络使用卷积层与使用全连接层的区别 卷积层：卷积运算的主要目的是使原信号特征增强，并降低噪音；每个输出特性不用查看每个输入特征，而只需查看部分输入特征，卷积核在图像上滑动过程中保持不变。 全连接层：对生成的特征进行加权；每个输出都是所有输入数据的加权求和。 总结卷积核、多通道卷积及池化操作 每个卷积核都会将图像生成为另一幅特征映射图，即：一个卷积核提取一种特征。为了使特征提取更充分，可以添加多个卷积核以提取不同的特征，也就是，多通道卷积。计算图像一个区域上的某个特定特征的平均值或最大值，这种聚合操作就叫做池化。卷积层的作用是探测上一层特征的局部连接，而池化的作用是在语义上把相似的特征合并起来，从而达到降维目的。 深度神经网络数据增强的主要方式 水平翻转，上下翻转、改变对比度、剪裁或填充后缩放，随机裁剪、白化处理、 Deep Dream的技术原理 假设输入图像是 x，把图像输入到卷积神经网络中，输出的结果是各个类别的概率，指定一个标签，通过预测结果与指定标签之间的误差来反向传播到输入图像，这里调整的是输入图像的像素值，而不是卷积神经网络，卷积神经网络的参数是固定的，所以只需要导入已经训练好的模型，预训练模型。在生成某一类别图像的时候，通过最大化输出层输出的这一类别的概率来实现目标，通过最大化卷积层某一通道的激活值来可视化卷积层的特征。]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio + UHD + OpenBTS 软件无线电平台搭建]]></title>
    <url>%2FGnuradio-UHD-OpenBTS-%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境ubuntu 16.04 (14.04) ubuntu 18 版本在后面会在装 OpenBTS 时因为 python-software-properties 依赖的问题卡住 换源并更新软件源/etc/apt/sources.list 路径下 推荐使用清华的源，旁边也有自动选择最快的服务器的选项 如果是在终端下进行换源则别忘了更新 sudo apt-get update GnuradioGNURadio 安装包下载地址 https://www.gnuradio.org/releases/gnuradio/ 选择 tar.gz 格式的安装包，这里我选用的是 Gnuradio3.7.9 可用 wget 下载 1、安装各种依赖库（可能不限于下面这些库） 1sudo apt-get -y install git swig cmake doxygen build-essential libboost-all-dev libtool libusb-1.0-0 libusb-1.0-0-dev libudev-dev libncurses5-dev libfftw3-bin libfftw3-dev libfftw3-doc libcppunit-1.13-0v5 libcppunit-dev libcppunit-doc ncurses-bin cpufrequtils python-numpy python-numpy-doc python-numpy-dbg python-scipy python-docutils qt4-bin-dbg qt4-default qt4-doc libqt4-dev libqt4-dev-bin python-qt4 python-qt4-dbg python-qt4-dev python-qt4-doc python-qt4-doc libfftw3-bin libfftw3-dev libfftw3-doc ncurses-bin libncurses5 libncurses5-dev libncurses5-dbg libfontconfig1-dev libxrender-dev libpulse-dev swig g++ automake autoconf libtool python-dev libfftw3-dev libcppunit-dev libboost-all-dev libusb-dev libusb-1.0-0-dev fort77 libsdl1.2-dev python-wxgtk2.8 git-core libqt4-dev python-numpy ccache python-opengl libgsl0-dev python-cheetah python-mako python-lxml doxygen qt4-default qt4-dev-tools libusb-1.0-0-dev libqwt5-qt4-dev libqwtplot3d-qt4-dev pyqt4-dev-tools python-qwt5-qt4 cmake git-core wget libxi-dev gtk2-engines-pixbuf r-base-dev python-tk liborc-0.4-0 liborc-0.4-dev libasound2-dev python-gtk2 libzmq1 libzmq-dev python-requests python-sphinx libcomedi-dev python-sip \pkg-config libxrender-dev python-sip-dev \libqt4-opengl-dev 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install python-wxgtk2.8 2、进入安装包下载目录，并将安装包解压到 /usr/local/ 目录下（root 模式） 12345678910tar -zxvf gnuradio.3.7.9.tar.gz -C /usr/localcd /usr/local/gnuradio-3.7.9/mkdir buildcd buildcmake ../makesudo make install sudo ldconfig#安装完毕输入sudo gnuradio-companion #启动Gnuradio 3、如果想省事的话，可以直接 1sudo apt-get install gnuradio UHD 安装UHD 我使用的是 release_003_009_005 ，可能因为 uhd 在3.10 左右的版本做的一个改动会导致在编译 OpenBTS ./build.sh B210 时无法进行下去 1、仅当需要连接真实 USRP 硬件设备时，才需要安装 UHD 固件 2、从 Ettus Research 官网下载适合的 UHD release版本 http://github.com/EttusResearch/UHD/tags 3、安装一些库 1sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-mako doxygen python-docutils cmake build-essential 4、将下载好的 UHD release 放到某个路径 下面 1234567cd &lt;path&gt;/hostmkdir buildcd buildcmake ../makesudo make installsudo ldcnfig 5、安装完成，下载 UHD 固件，可以使用自带的脚本下载对应的固件 12cd /usr/local/lib/uhd/utilssudo ./uhd_images_downloader.py 若出现 ImportError: No module named requests 这时安装 requests 1pip install requests 若显示 pip 尚未安装，则西安安装 pip，再安装 requests 12sudo apt install python-pippip install requests 安装完毕接着执行 12345sudo ./uhd_images_downloader.py......#提示如下Images successfully installed to:/usr/local/share/uhd/images 连接真实 USRP 硬件后， 在终端键入 uhd_find_devices 会显示当前链接的 USRP 的参数，说名 UHD 安装成功 OpenBTS 安装1、安装依赖 1sudo apt-get install software-properties-common python-software-properties git 2、下载源码 123456mkdir openbts &amp;&amp; cd openbtsgit clong https://github.com/RangeNetworks/dev.gitcd dev./clone.sh./switchto.sh master #选择分支./build.sh B210 #编译 3、./build.sh B210 可能会遇到一些问题 libzmq5 unable to install ​ *原因：OpenBTS对Ubuntu 16.04的支持导致某些依赖版本较高 ​ *解决方法：把 build.sh 中的 libzmq5 改成 libzmq3，重新执行 ./build.sh B210 openbts boost/config.hpp: No such file or directory ​ *解决方法：sudo apt-get install libboost-dev ‘class uhd::rx_Streamer’ has no member named ‘issue_stream_cmd’, ‘class uhd::tx_Streamer’ has no member named ‘recv_async_msg’ ​ *解决方法：安装Ettus Ubuntu PPA中的libuhd-dev libuhd003 uhd-host 123sudo add-apt-repository ppa:ettusresearch/uhdsudo apt-get updatesudo apt-get install libuhd-dev libuhd003 uhd-host /usr/bin/ld: cannot find -lboost_system ​ 解决方法：sudo ldconfig​ 备用方法：sudo apt-get install libboost-system1.54-dev 4、安装 12cd BUILDSsudo dpkg -i [编译成功时间]/*.deb 123a.建议先安装依赖deb包(liba53, libcoredumper)，接下来安装应用deb包(range-asterisk, sipauthserve, smqueue, openbts)，最后安装配置deb包(range-asterisk-config, range-configs)b.若配置deb包的配置文件与已安装应用配置文件冲突，选择配置deb包的文件c.如遇依赖问题，无法安装某些deb包，使用 sudo apt-get -f install 5|、启动/停止 OpenBTS 1234sudo start/stop sipauthservesudo start/stop smqueuesudo start/stop openbtssudo start/stop asterisk 发现 ubuntu 不再支持 upstart 的启动管理方式了 于是用 systemctl 启动 发现缺少 .service 文件 openbts_systemd_scripts 解压后将其中 systemd 中的四个 .service 文件复制到 /etc/systemd/system/ 然后 openbts-cli.sh 、openbts-start.sh 、openbts-stop.sh 三个文件分别为客户端，启动服务，停止服务的执行脚本 可以看后四项服务的 PID 则说明服务已启动 6、OpenBTS 控制终端 123cd /OpenBTS#sudo ./OpenBTS sudo ./OpenBTSCLI #OpenBTSCLI 需要 OpenBTS 先行启动 注意事项-必须采用 su 用户才可以 open USB 之后再运行 uhd_usrp_probe 成功烧写固件和 FPGA -OpenBTS及asterisk等应用默认开机启动，若系统安装其他GSM相关应用，如gr-gsm，注意sudo stop openbts，避连接B210时冲突 -若uhd_usrp_probe或sudo ./OpenBTSCLI提示无设备，拔插再试 -本实验中使用的 B210 的 USB 接口是3.0，所以虚拟机 USB 兼容性设为 3.0 -若在开放注册的时候出现下图警告，则需要调整增益，将 RxGain 降低 设备连接以及固件烧录过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124hengyud@ubuntu:/OpenBTS$ sudo -iroot@ubuntu:~# uhd_find_devices linux; GNU C++ version 5.4.0 20160609; Boost_105800; UHD_003.009.005-0-unknown---------------------------------------------------- UHD Device 0--------------------------------------------------Device Address: type: b200 name: MyB210 serial: 30F7D88 product: B210root@ubuntu:~# uhd_usrp_probelinux; GNU C++ version 5.4.0 20160609; Boost_105800; UHD_003.009.005-0-unknown-- Detected Device: B210-- Loading FPGA image: /usr/local/share/uhd/images/usrp_b210_fpga.bin... done-- Operating over USB 3.-- Detecting internal GPSDO.... No GPSDO found-- Initialize CODEC control...-- Initialize Radio control...-- Performing register loopback test... pass-- Performing register loopback test... pass-- Performing CODEC loopback test... pass-- Performing CODEC loopback test... pass-- Asking for clock rate 16.000000 MHz... -- Actually got clock rate 16.000000 MHz.-- Performing timer loopback test... pass-- Performing timer loopback test... pass-- Setting master clock rate selection to &apos;automatic&apos;. _____________________________________________________ /| Device: B-Series Device| _____________________________________________________| /| | Mboard: B210| | revision: 4| | product: 2| | serial: 30F7D88| | name: MyB210| | FW Version: 8.0| | FPGA Version: 13.0| | | | Time sources: none, internal, external, gpsdo| | Clock sources: internal, external, gpsdo| | Sensors: ref_locked| | _____________________________________________________| | /| | | RX DSP: 0| | | Freq range: -8.000 to 8.000 MHz| | _____________________________________________________| | /| | | RX DSP: 1| | | Freq range: -8.000 to 8.000 MHz| | _____________________________________________________| | /| | | RX Dboard: A| | | _____________________________________________________| | | /| | | | RX Frontend: A| | | | Name: FE-RX2| | | | Antennas: TX/RX, RX2| | | | Sensors: temp, rssi, lo_locked| | | | Freq range: 50.000 to 6000.000 MHz| | | | Gain range PGA: 0.0 to 76.0 step 1.0 dB| | | | Bandwidth range: 200000.0 to 56000000.0 step 0.0 Hz| | | | Connection Type: IQ| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | RX Frontend: B| | | | Name: FE-RX1| | | | Antennas: TX/RX, RX2| | | | Sensors: temp, rssi, lo_locked| | | | Freq range: 50.000 to 6000.000 MHz| | | | Gain range PGA: 0.0 to 76.0 step 1.0 dB| | | | Bandwidth range: 200000.0 to 56000000.0 step 0.0 Hz| | | | Connection Type: IQ| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | RX Codec: A| | | | Name: B210 RX dual ADC| | | | Gain Elements: None| | _____________________________________________________| | /| | | TX DSP: 0| | | Freq range: -8.000 to 8.000 MHz| | _____________________________________________________| | /| | | TX DSP: 1| | | Freq range: -8.000 to 8.000 MHz| | _____________________________________________________| | /| | | TX Dboard: A| | | _____________________________________________________| | | /| | | | TX Frontend: A| | | | Name: FE-TX2| | | | Antennas: TX/RX| | | | Sensors: temp, lo_locked| | | | Freq range: 50.000 to 6000.000 MHz| | | | Gain range PGA: 0.0 to 89.8 step 0.2 dB| | | | Bandwidth range: 200000.0 to 56000000.0 step 0.0 Hz| | | | Connection Type: IQ| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | TX Frontend: B| | | | Name: FE-TX1| | | | Antennas: TX/RX| | | | Sensors: temp, lo_locked| | | | Freq range: 50.000 to 6000.000 MHz| | | | Gain range PGA: 0.0 to 89.8 step 0.2 dB| | | | Bandwidth range: 200000.0 to 56000000.0 step 0.0 Hz| | | | Connection Type: IQ| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | TX Codec: A| | | | Name: B210 TX dual DAC| | | | Gain Elements: None 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495hengyud@ubuntu:/OpenBTS$ sudo ./OpenBTSALERT 43213:43213 2019-05-12T00:37:07.6 OpenBTS.cpp:595:main: OpenBTS (re)starting, ver 5.0-master build date/time 2019-04-28T22:47:15ALERT 43213:43213 2019-05-12T00:37:07.6 OpenBTS.cpp:596:main: OpenBTS reading config file /etc/OpenBTS/OpenBTS.db1557646627.677025 140203525388096: OpenBTSCopyright 2008, 2009, 2010 Free Software Foundation, Inc.Copyright 2010 Kestrel Signal Processing, Inc.Copyright 2011, 2012, 2013, 2014 Range Networks, Inc.Release 5.0-master+646bb6e79f CommonLibs:76b71d509b P formal build date 2019-04-28T22:41:36&quot;OpenBTS&quot; is a registered trademark of Range Networks, Inc.Contributors: Range Networks, Inc.: David Burgess, Harvind Samra, Donald Kirker, Doug Brown, Pat Thompson, Kurtis Heimerl, Michael Iedema, Dave Gotwisner Kestrel Signal Processing, Inc.: David Burgess, Harvind Samra, Raffi Sevlian, Roshan Baliga GNU Radio: Johnathan Corgan Others: Anne Kwong, Jacob Appelbaum, Joshua Lackey, Alon Levy Alexander Chemeris, Alberto Escudero-PascualIncorporated L/GPL libraries and components: libortp, LGPL, 2.1 Copyright 2001 Simon MORLAT simon.morlat@linphone.org libusb, LGPL 2.1, various copyright holders, www.libusb.org libzmq, LGPL 3: Copyright (c) 2009-2011 250bpm s.r.o. Copyright (c) 2011 Botond Ballo Copyright (c) 2007-2009 iMatix CorporationIncorporated BSD/MIT-style libraries and components: A5/1 Pedagogical Implementation, Simplified BSD License, Copyright 1998-1999 Marc Briceno, Ian Goldberg, and David Wagner JsonBox, Copyright 2011 Anhero Inc. Google Core Dumper, BSD 3-Clause License, Copyright (c) 2005-2007, Google Inc.Incorporated public domain libraries and components: sqlite3, released to public domain 15 Sept 2001, www.sqlite.orgThis program comes with ABSOLUTELY NO WARRANTY.Use of this software may be subject to other legal restrictions,including patent licensing and radio spectrum licensing.All users of this software are expected to comply with applicableregulations and laws. See the LEGAL file in the source code formore information.Note to US Government Users: The OpenBTS software applications and associated documentation are &quot;Commercial Item(s),&quot; as that term is defined at 48 C.F.R. Section 2.101, consisting of &quot;Commercial Computer Software&quot; and &quot;Commercial Computer Software Documentation,&quot; as such terms are used in 48 C.F.R. 12.212 or 48 C.F.R. 227.7202, as applicable. Consistent with 48 C.F.R. 12.212 or 48 C.F.R. Sections 227.7202-1 through 227.7202-4, as applicable, the Commercial Computer Software and Commercial Computer Software Documentation are being licensed to U.S. Government end users (a) only as Commercial Items and (b) with only those rights as are granted to all other end users pursuant to the terms and conditions of Range Networks&apos; software licenses and master customer agreement.1557646627.703102 140203525388096: Starting the system...ALERT 43213:43220 2019-05-12T00:37:12.7 OpenBTS.cpp:174:startTransceiver: starting transceiver ./transceiver with 1 ARFCNslinux; GNU C++ version 5.4.0 20160609; Boost_105800; UHD_003.009.005-0-unknownUsing internal frequency reference-- Detected Device: B210-- Operating over USB 2.-- Initialize CODEC control...-- Initialize Radio control...-- Performing register loopback test... pass-- Performing register loopback test... pass-- Performing CODEC loopback test... pass-- Performing CODEC loopback test... pass-- Asking for clock rate 16.000000 MHz... -- Actually got clock rate 16.000000 MHz.-- Performing timer loopback test... pass-- Performing timer loopback test... pass-- Setting master clock rate selection to &apos;automatic&apos;.-- Asking for clock rate 32.000000 MHz... -- Actually got clock rate 32.000000 MHz.-- Performing timer loopback test... pass-- Performing timer loopback test... pass-- Asking for clock rate 26.000000 MHz... -- Actually got clock rate 26.000000 MHz.-- Performing timer loopback test... pass-- Performing timer loopback test... pass1557646638.143648 140203525388096: system ready1557646638.143858 140203525388096: use the OpenBTSCLI utility to access CLI1557646638.144045 140203525388096: OpenBTSCLI network socket support for tcp:49300OpenBTS&gt; OpenBTS操作指南]]></content>
      <categories>
        <category>软件无线电</category>
      </categories>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理：简单绘图语言解释器的实现]]></title>
    <url>%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AE%80%E5%8D%95%E7%BB%98%E5%9B%BE%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[为函数绘图语言编写一个解释器。​ 解释器接受用绘图语言编写的源程序，经语法和语义分析之后，将源程序所规定的图形显示在显示屏（或窗口）中。 目的​ 通过自己动手编写解释器，掌握语言翻译特别是语言识别的基本方法，加深对编译器构造原理和方法的理解，巩固所学。 &lt;1> 会用正规式和产生式设计简单语言的语法； &lt;2> 会用递归下降子程序编写编译器或解释器； 语句原则1、各类语句可以按任意次序书写，且语句以分号结尾。源程序中的语句以它们出现的先后顺序处理。 2、ORIGIN、ROT 和 SCALE 语句只影响其后的绘图语句，且遵循最后出现的语句有效的原则。例如，若有下述ROT语句序列： ​ ROT IS 0.7 ； ROT IS 1.57 ； ​ 则随后的绘图语句将按1.57而不是0.7弧度旋转。 3、无论 ORIGIN、ROT 和 SCALE 语句的出现顺序如何，图形的变换顺序总是： ​ 比例变换→旋转变换→平移变换 4、语言对大小写不敏感，如 for、For、FOR 等，均被认为是同一个保留字。 5、语句中表达式的值均为双精度类型，旋转角度单位为弧度且为逆时针旋转，平移单位为点。 语句的语法与语义循环绘图（FOR-DRAW）语句语法： ​ FOR T FROM 起点 TO 终点 STEP 步长 DRAW (横坐标, 纵坐标); 语义 ​ 令 T 从起点到终点、每次改变一个步长，绘制出由 (横坐标，纵坐标) 所规定的点的轨迹。 举例 ​ FOR T FROM 0 TO 2*PI STEP PI/50 DRAW (cos(T), sin(T)); 说明 ​ 该语句的作用是令 T 从 0 到 2*PI、步长 PI/50，绘制出各个点的坐标 (cos(T)，sin(T))，即一个单位圆。 注意 ​ 由于绘图系统的默认值是 12345ORIGIN IS (0,0);ROT IS 0;SCALE IS (1, 1); ​ 所以实际绘制出的图形是在屏幕左上角的一个点。 比例设置(SCALE)语句语法 ​ SCALE IS (横坐标比例因子，纵坐标比例因子); 语义 ​ 设置横坐标和纵坐标的比例，并分别按照比例因子进行缩放。 举例 ​ SCALE IS (100, 100); 说明 ​ 将横坐标和纵坐标的比例设置为 1:1，且放大 100 倍。 ​ 若： SCALE IS (100, 100/3); ​ 则：横坐标和纵坐标的比例为 3:1 角度旋转(ROT)语句语法 ​ ROT IS 角度； 语义 ​ 逆时针旋转角度所规定的弧度值。具体计算公式： 旋转后X=旋转前X*COS(角度)+旋转前Y*SIN(角度) 旋转后Y=旋转前Y*COS(角度)-旋转前X*SIN(角度) 举例 ​ ROT IS PI/2; 说明 ​ 逆时针旋转PI/2，即逆时针旋转90度。 注释语句注释的作用 便于理解 屏蔽暂时不需要的语句 语法 ​ // This is a comment line ​ 或 -- 此行是注释 语义 ​ // 或 -- 之后，直到行尾，均是注释 记号的语法和语义记号的种类 ​ 常数、参数、函数、保留字、运算符、分隔符 &lt;1> 常数 ​ 常数字面量和标识符形式的常量名均称为常数。字面量的形式为普通的数值，如果没有小数部分，可以省略小数点。例如 2、 2.、 2.0 都是合法的常数。 标识符 PI、E 也是常数，它们分别代表圆周率和自然对数的底。常数不能有符号位，如 -1 和 +2 不是常数而是（一元运算的）表达式。 &lt;2> 参数 ​ 本作图语言中唯一的、已经被定义好的变量名 T 被称为参数，它也是一个表达式。由于作图语言中只有这唯一的变量，因此作图语言中无需变量或参数的声明和定义语句。 &lt;3> 函数（调用） ​ 为简单起见，当前函数调用仅支持 Sin、Cos、Tan、Sqrt 以及 Exp 和 Ln。有兴趣的同学可以再加入其他函数。 &lt;4> 保留字 ​ 语句中具有固定含义的标识符，包括： 123ORIGIN, SCALE, ROT, IS, TO,STEP, DRAW, FOR, FROM &lt;5> 运算符 ​ PLUS, MINUS, MUL, DIV, POWER 即 + - * / ** &lt;6> 分隔符 ​ SEMICO, L_BRACKET, R_BRACKET, COMMA 即 ; ( ) , 开发环境及配置​ 采用C/C++程序设计语言使用 Visual Studio Community 2017 编写 Windows 桌面应用程序，分为三大模块：词法分析器、语法分析器和绘图解释器。 基本原理与解决思路​ 词法分析器用于识别出文件流中符合我们定义的记号，供语法分析器调用；语法分析器用于构造语法分析树，计算出表达式的值，包括原点坐标、旋转角度、横纵坐标比例和缩放大小，以及循环绘制语句的各项参数；绘图解释器，读取语法分析器产生的结果，计算出每一个点的 (x, y) 坐标，使用 “描点法” 绘制出完整的函数图像，并调用系统窗口显示相关的函数，以窗口的形式展示函数图像 ​ 词法分析器将文件作为数据流进行处理，依次将数据流的一个字符取出，或者放回，按照实现构造的记号表识别文件流中的记号流，将其与设定的函数绘图语句的模式进行匹配，引出一个 GetToken() 接口被语法分析器调用。 ​ 词法分析器作为一个子函数被语法分析器调用，读取记号的同时构建语法树，计算表达式的值，并将绘图所需的参数保存在相应的变量中。按照语句顺序，依次对每个记号进行分析，对于保留字，采用 MatchToken() 匹配成功后，对下一个记号进行分析，而对于其它的记号符号，则调用 Expression() 生成语法树，再用 GetExprValue() 递归下降计算出值，最后删除语法树。 ​ 语法分析器在分析的过程中会计算表达式的值，将其储存到变量中调用系统的 SetPixel(hDC, x, y, black) 在窗口中的 (x, y) 坐标画一个黑色的点利用描点法的思想，在循环体中让参数 Parameter 从 Start 循环到 End 每次增加 Step，然后在每次循环中根据比例、 平移和旋转角度，计算每一个 (x, y)，在窗口中绘制点。 关键类及主要方法1234567891011enum Token_Type &#123; //记号种类 ORIGIN, SCALE, ROT, IS, TO, //保留字 STEP, DRAW, FOR, FROM, T, //参数 SEMICO, L_BRACKET, R_BRACKET, COMMA, //分隔符号 PLUS, MINUS, MUL, DIV, POWER, //运算符 FUNC, //函数 CONST_ID, //常数 NONTOKEN, //空记号 ERRTOKEN //出错记号&#125;; 123456struct Token &#123; // 记号的数据结构 Token_Type type; // 类别 char *lexeme; // 构成记号的字符串 double value; // 若为常数，则是常数的值 double(*FuncPtr)(double); // 若为函数，则是函数的指针&#125;; 1234567891011121314151617181920static Token TokenTab[] = &#123; &#123; CONST_ID, "PI", 3.1415926, NULL &#125;, &#123; CONST_ID, "E", 2.71828, NULL &#125;, &#123; T, "T", 0.0, NULL &#125;, &#123; FUNC, "SIN", 0.0, sin &#125;, &#123; FUNC, "COS", 0.0, cos &#125;, &#123; FUNC, "TAN", 0.0, tan &#125;, &#123; FUNC, "LN", 0.0, log &#125;, &#123; FUNC, "EXP", 0.0, exp &#125;, &#123; FUNC, "SQRT", 0.0, sqrt &#125;, &#123; ORIGIN, "ORIGIN", 0.0, NULL &#125;, &#123; SCALE, "SCALE", 0.0, NULL &#125;, &#123; ROT, "ROT", 0.0, NULL &#125;, &#123; IS, "IS", 0.0, NULL &#125;, &#123; FOR, "FOR", 0.0, NULL &#125;, &#123; FROM, "FROM", 0.0, NULL &#125;, &#123; TO, "TO", 0.0, NULL &#125;, &#123; STEP, "STEP", 0.0, NULL &#125;, &#123; DRAW, "DRAW", 0.0, NULL &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596extern Token GetToken(void) &#123;//获取一个记号 Token token; int Char; memset(&amp;token, 0, sizeof(Token)); EmptyTokenString(); token.lexeme = TokenBuffer; for (;;)&#123; //过滤源程序中的空格、TAB、回车等 Char = GetChar(); if (Char == EOF) &#123; token.type = NONTOKEN; return token; &#125; if (Char == '\n') LineNo++; if (!isspace(Char)) break;// 空白字符，返回非0值不是空白字符，跳出for循环 &#125; AddCharTokenString(Char); //若不是空格、TAB、回车、文件结束符等，则先加入到记号的字符缓冲区中 if (isalpha(Char))&#123; //若char是A-Za-z，则一定是函数、关键字、PI、E等。 for(;;)&#123; Char = GetChar(); if (isalnum(Char)) //判断Char是否为字母或者数字,是则返回非0，否则返回0; AddCharTokenString(Char); //Char是字母或者数字 else break; &#125; BackChar(Char); token = JudgeKeyToken(TokenBuffer); token.lexeme = TokenBuffer; return token; &#125; else if (isdigit(Char))&#123; //若是一个数字，则一定是常量 for (;;)&#123; Char = GetChar(); if (isdigit(Char)) AddCharTokenString(Char); else break; &#125; if (Char == '.')&#123; AddCharTokenString(Char); for (;;)&#123; Char = GetChar(); if(isdigit(Char)) AddCharTokenString(Char); else break; &#125; &#125;//end of if(Char == '.') BackChar(Char); //把预读的字符退回到输入源程序中 token.type = CONST_ID; token.value = atof(TokenBuffer); //把字符串转换成浮点数 return token; &#125;else&#123; //不是字母和数字，则一定是运算符或分隔符 switch (Char)&#123; case ';':token.type = SEMICO; break; case '(':token.type = L_BRACKET; break; case ')':token.type = R_BRACKET; break; case ',':token.type = COMMA; break; case '+':token.type = PLUS; break; case '-': Char = GetChar(); if (Char == '-')&#123; while (Char != '\n' &amp;&amp; Char != EOF) Char = GetChar(); BackChar(Char); return GetToken(); &#125;else&#123; BackChar(Char); token.type = MINUS; break; &#125; case '/': Char = GetChar(); if (Char == '/')&#123; while (Char != '\n' &amp;&amp; Char != EOF) Char = GetChar(); BackChar(Char); return GetToken(); &#125;else&#123; BackChar(Char); token.type = DIV; break; &#125; case '*': Char = GetChar(); if (Char == '*')&#123; token.type = POWER; break; &#125;else&#123; BackChar(Char); token.type = MUL; break; &#125; default: token.type = ERRTOKEN; break; &#125;// end of switch &#125;//end of else(不是字母和数字，则一定是符号) return token;&#125;//end of GetToken 12345678910111213141516171819202122232425void PrintSyntaxTree(struct ExprNode *root, int indent)&#123; int temp; for (temp = 1; temp &lt;= indent; temp++) printf("\t");//缩进 switch (root-&gt;OpCode)&#123; case PLUS: printf("%s\n", "+"); break; case MINUS: printf("%s\n", "-"); break; case MUL: printf("%s\n", "*"); break; case DIV: printf("%s\n", "/"); break; case POWER: printf("%s\n", "**"); break; case FUNC: printf("%x\n", root-&gt;Content.CaseFunc.MathFuncPtr); break; case CONST_ID: printf("%f\n", root-&gt;Content.CaseConst); break; case T: printf("%s\n", "T"); break; default: printf("Error Tree Node !\n"); exit(0); &#125; if (root-&gt;OpCode == CONST_ID || root-&gt;OpCode == T) //叶子节点返回 return;//常数和参数只有叶子节点 常数：右值；参数：左值地址 if (root-&gt;OpCode == FUNC)//递归打印一个孩子节点 PrintSyntaxTree(root-&gt;Content.CaseFunc.Child, indent + 1); else//递归打印两个孩子节点 &#123;//二元运算：左右孩子的内部节点 PrintSyntaxTree(root-&gt;Content.CaseOperator.Left, indent + 1); PrintSyntaxTree(root-&gt;Content.CaseOperator.Right, indent + 1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536static void ForStatement(void)&#123; double Start, End, Step;//绘图起点、终点、步长 struct ExprNode *start_ptr, *end_ptr, *step_ptr, *x_ptr, *y_ptr; MatchToken(FOR); MatchToken(T); MatchToken(FROM);//eg:for T from start_ptr = Expression(); //构造参数起点表达式的语法树 Tree_trace(start_ptr); Start = GetExprValue(start_ptr);//计算参数起点表达式的值 DelExprTree(start_ptr);//释放参数起点语法树所占空间 MatchToken(TO); end_ptr = Expression();//构造参数终点表达式语法树 Tree_trace(end_ptr); End = GetExprValue(end_ptr);//计算参数终点表达式的值 DelExprTree(end_ptr);//释放参数终点语法树所占空间 MatchToken(STEP); step_ptr = Expression();//构造参数步长表达式语法树 Tree_trace(step_ptr); Step = GetExprValue(step_ptr);//计算参数步长表达式的值 DelExprTree(step_ptr);//释放参数步长语法树所占空间 MatchToken(DRAW); MatchToken(L_BRACKET); x_ptr = Expression(); Tree_trace(x_ptr); MatchToken(COMMA); y_ptr = Expression(); Tree_trace(y_ptr); MatchToken(R_BRACKET); DrawLoop(Start, End, Step, x_ptr, y_ptr); //绘制图形 DelExprTree(x_ptr);//释放横坐标语法树所占空间 DelExprTree(y_ptr);//释放纵坐标语法树所占空间&#125; 测试截图Parsertest.cpp 进行词法分析测试​ 我们的测试程序test.cpp与main.cpp中都存在main函数，所以我们在测试各模块功能的时候需要将其它部分从项目生成中排除 12345678910111213141516#include "scanner.h"#include &lt;stdio.h&gt;void main(int argc, char *argv[])&#123; Token token; InitScanner("D:\\1.txt"); printf("记号类别 字符串 常数值 函数指针\n"); printf("____________________________________________\n"); while(1)&#123; token = GetToken(); // 通过词法分析器获得一个记号 if (token.type != NONTOKEN) // 打印记号的内容 printf("%4d,%12s,%12f,%12x\n",token.type, token.lexeme, token.value, token.FuncPtr); else break; // 源程序结束，退出循环 &#125;; system("pause"); CloseScanner(); // 关闭词法分析器&#125; parsertest.cpp 进行语法分析测试123456789101112131415#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include "parser.h"extern void Parser(char *SrcFilePtr);//测试主程序void main(int argc,char *argv[])&#123; char *p; p = (char*)malloc(20 * sizeof(char)); memset(p, 0, sizeof(char) * 20); strcpy(p, "D:\\1.txt"); Parser(p);//调用parser进行语法分析 free(p); system("pause");&#125; ​ 在进行这一部分的测试时，需要将 parser.cpp 中的 GetExprValue() 语句注释掉，将 ForStatement() 中的 DrawLoop(Start, End, Step, x_ptr, y_ptr) 注释掉，因为它们会调用 semantic.cpp 中的绘图解释器函数；将所有含 Expression() 的语句后面加上 Tree_trace(), 在控制台中打印语法树，它是宏定义 #define Tree_trace(x) PrintSyntaxTree(x,1)； 绘图解释器的测试首先需要将子系统从控制台调为窗口，因为在 main.cpp 中 winmain 窗口函数 12345678910111213141516171819202122232425int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; strcpy(SrcFilePath, "D:\\1.txt");//保存原文件路径 if (PrepareWindow(hInstance, hPrevInstance, nCmdShow) != true)//初始化窗口 &#123; MessageBox(NULL, "窗口初始化失败", "错误", MB_OK); return 1; &#125; //检查要分析的源程序文件 if (!CheckSrcFile(SrcFilePath)) return 1; //调用绘图语言解释器 Parser(SrcFilePath); //进入window消息循环 MSG Msg; while (GetMessage(&amp;Msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;Msg); DispatchMessage(&amp;Msg); &#125; return Msg.wParam;&#125; 遇到的问题及解决办法​ 在 scanner.h 文件中，出现了 const char* 类型的值不能用于初始化 char* 类型的实体错误 ​ 可以看到报错是C2400，找到的解决方法是关闭符合模式 ​ 位置在项目属性中的c/c++>>语言>>符合模式 ​ 遇见了 LNK2019 外部符号错误，这里是由于 main.cpp 中的窗口函数的缘故需要窗口子系统 ​ LNK2001：无法解析的struct HDC__* hDC，这个错误是semantic.h中的外部引用extern HDC hDC出现的问题，只需要在semantic.cpp中声明一下HDC hDC即可 附：测试视频及项目代码]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>简单绘图语言解释器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现hangman游戏]]></title>
    <url>%2FPython%E5%AE%9E%E7%8E%B0hangman%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[IntroductionFor this problem, you will implement a variation of the classic word game Hangman. In this problem, the second player will always be the computer, who will be picking a word at random. In this problem, you will implement a function, called hangman, that will start up and carry out an interactive Hangman game between a player and the computer. Before we get to this function, we’ll first implement a few helper functions to get you going. For this problem, you will need the code file words.txt. The code we have given you loads in a list of words from a file. If everything is working okay, after a small delay, you should see the following printed out: Loading word list from file… 55909 words loaded. If you see an IOError instead (e.g., “No such file or directory”), you should change the value of the WORDLIST_FILENAME constant (defined near the top of the file) to the complete pathname for the file words.txt (This will vary based on where you saved the file). Windows users, change the backslashes to forward slashes, like below. For example, if you saved ps3_hangman.py and words.txt in the directory “C:/Users/Ana/“ change the line: WORDLIST_FILENAME = “words.txt” to something like WORDLIST_FILENAME = “C:/Users/Ana/words.txt” This folder will vary depending on where you saved the files. Requirements The computer must select a word at random from the list of available words that was provided in words.txt. The functions for loading the word list and selecting a random word have already been provided for you. The game must be interactive; the flow of the game should go as follows: At the start of the game, let the user know how many letters the computer’s word contains. Ask the user to supply one guess (i.e. letter) per round. The user should receive feedback immediately after each guess about whether their guess appears in the computer’s word. After each round, you should also display to the user the partially guessed word so far, as well as letters that the user has not yet guessed. Some additional rules of the game: A user is allowed 8 guesses. Make sure to remind the user of how many guesses s/he has left after each round. Assume that players will only ever submit one character at a time (A-Z). A user loses a guess only when s/he guesses incorrectly. If the user guesses the same letter twice, do not take away a guess - instead, print a message letting them know they’ve already guessed that letter and ask them to try again. The game should end when the user constructs the full word or runs out of guesses. If the player runs out of guesses (s/he “loses”), reveal the word to the user when the game ends. Sample OutputThe output of a winning game should look like this…1234567891011121314151617181920212223242526272829303132333435363738394041Loading word list from file...55900 words loaded.Welcome to the game, Hangman!I am thinking of a word that is 4 letters long.*************You have 8 guesses left.Available letters: abcdefghijklmnopqrstuvwxyzPlease guess a letter: aGood guess: _ a_ _*************You have 8 guesses left.Available letters: bcdefghijklmnopqrstuvwxyzPlease guess a letter: aOops! You&apos;ve already guessed that letter: _ a_ _*************You have 8 guesses left.Available letters: bcdefghijklmnopqrstuvwxyzPlease guess a letter: sOops! That letter is not in my word: _ a_ _*************You have 7 guesses left.Available letters: bcdefghijklmnopqrtuvwxyzPlease guess a letter: tGood guess: ta_ t*************You have 7 guesses left.Available letters: bcdefghijklmnopqruvwxyzPlease guess a letter: rOops! That letter is not in my word: ta_ t*************You have 6 guesses left.Available letters: bcdefghijklmnopquvwxyzPlease guess a letter: mOops! That letter is not in my word: ta_ t*************You have 5 guesses left.Available letters: bcdefghijklnopquvwxyzPlease guess a letter: cGood guess: tact*************Congratulations, you won! And the output of a losing game should look like this…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Loading word list from file...55900 words loaded.Welcome to the game, Hangman!I am thinking of a word that is 3 letters long.*************You have 8 guesses left.Available letters: abcdefghijklmnopqrstuvwxyzPlease guess a letter: aOops! That letter is not in my word: _ _ _*************You have 7 guesses left.Available letters: bcdefghijklmnopqrstuvwxyzPlease guess a letter: bOops! That letter is not in my word: _ _ _*************You have 6 guesses left.Available letters: cdefghijklmnopqrstuvwxyzPlease guess a letter: cOops! That letter is not in my word: _ _ _*************You have 5 guesses left.Available letters: defghijklmnopqrstuvwxyzPlease guess a letter: dOops! That letter is not in my word: _ _ _*************You have 4 guesses left.Available letters: efghijklmnopqrstuvwxyzPlease guess a letter: eOops! That letter is not in my word: _ _ _*************You have 3 guesses left.Available letters: fghijklmnopqrstuvwxyzPlease guess a letter: fGood guess: f_ _*************You have 3 guesses left.Available letters: ghijklmnopqrstuvwxyzPlease guess a letter: gOops! That letter is not in my word: f_ _*************You have 2 guesses left.Available letters: hijklmnopqrstuvwxyzPlease guess a letter: hOops! That letter is not in my word: f_ _*************You have 1 guesses left.Available letters: ijklmnopqrstuvwxyzPlease guess a letter: iGood guess: fi_*************You have 1 guesses left.Available letters: jklmnopqrstuvwxyzPlease guess a letter: kOops! That letter is not in my word: fi_*************Sorry, you ran out of guesses. The word was fit We’ll start by writing 3 simple functions that will help us easily code the Hangman problem分别是三个小功能 isWordGuessed、getGuessedWord、getAvailableLetters 函数与 hangman 游戏主程序的实现。Problem 1 - Is the Word Guessed123456789101112131415161718First, implement the function isWordGuessed that takes in two parameters - a string: secretWord - a list of letters: lettersGuessed.This function returns a boolean - True if secretWord has been guessed (ie, all the letters of secretWord are in lettersGuessed) - False otherwise.Example Usage:secretWord = &apos;apple&apos;lettersGuessed = [&apos;e&apos;, &apos;i&apos;, &apos;k&apos;, &apos;p&apos;, &apos;r&apos;, &apos;s&apos;]print(isWordGuessed(secretWord, lettersGuessed))FalseFor this function, you may assume that all the lettersin secretWord and lettersGuessed are lowercase. ​ 这部分主要是判断猜测的 secretWord 中的字母是否都在从一开始至今猜测过的字母集中，如果是返回 True 否则 False ​ isWordGuessed(secretWord, lettersGuessed) 1234#secretWord: string, the word the user is guessing#lettersGuessed: list, what letters have been guessed so far#returns: boolean, True if all the letters of secretWord are #in lettersGuessed;# False otherwise 12345def isWordGuessed(secretWord, lettersGuessed): for i in range(len(secretWord)): if secretWord[i] not in lettersGuessed: return False return True Problem 2 - print the guess word1234567891011121314151617181920212223242526272829implement the function getGuessedWord that takes in two parameters - a string, secretWord, and - a list of letters, lettersGuessed.This function returns a string that is comprised of letters and underscores,based on what letters in lettersGuessed are in secretWord. This shouldn&apos;t be too different from isWordGuessed!Example Usage:secretWord = &apos;apple&apos;lettersGuessed = [&apos;e&apos;, &apos;i&apos;, &apos;k&apos;, &apos;p&apos;, &apos;r&apos;, &apos;s&apos;]print(getGuessedWord(secretWord, lettersGuessed))&apos;_ pp_ e&apos;When inserting underscores into your string, it&apos;s a good ideato add at least a space after each one, so it&apos;s clear to theuser how many unguessed letters are left in the string(compare the readability of ____ with _ _ _ _ ).This is called usability - it&apos;s very important,when programming, to consider the usability of your program.If users find your program difficult to understand or operate,they won&apos;t use it!For this problem, you are free to use spacing in any way you wishWe do encourage you to think about usability when designing.For this function, you may assume that all the letters insecretWord and lettersGuessed are lowercase. ​ 这部分的主要功能则是将所猜单词猜中的字母在单词中的位置打印出来，未猜出部分用 “_ “ 部分来代替。 1234就是形如secretWord = 'apple' lettersGuessed = ['e', 'i', 'k', 'p', 'r', 's'] 输出结果为 '_ pp_ e' ​ getGuessedWord(secretWord, lettersGuessed) 123#secretWord: string, the word the user is guessing#lettersGuessed: list, what letters have been guessed so far#returns: string, comprised of letters and underscores that # represents what letters in secretWord have been guessed # so far. 12345678def getGuessedWord(secretWord, lettersGuessed): list1 = list() for i in range(len(secretWord)): if secretWord[i] in lettersGuessed: list1.append(secretWord[i]) else: list1.append("_") return ' '.join(list1) Problem 3 - print the avaiable letters123456789101112131415161718192021222324implement the function getAvailableLetters that takesin one parameter - a list of letters, lettersGuessed.This function returns a string that is comprised oflowercase English letters - all lowercase English lettersthat are not in lettersGuessed.Example Usage:lettersGuessed = [&apos;e&apos;, &apos;i&apos;, &apos;k&apos;, &apos;p&apos;, &apos;r&apos;, &apos;s&apos;]print(getAvailableLetters(lettersGuessed))abcdfghjlmnoqtuvwxyzNote that this function should return the letters in alphabetical order,as in the example above.For this function, you may assume that all the letters in lettersGuessedare lowercase.Hint: You might consider using string.ascii_lowercase,which is a string comprised of all lowercase letters:import stringprint(string.ascii_lowercase)abcdefghijklmnopqrstuvwxyz ​ 这部分的功能是返回字母表中没有猜过的字母，借用 string 库中的string.ascii_lowercase 功能模块协助实现 ​ getAvailableLetters(lettersGuessed) 123#lettersGuessed: list, what letters have been guessed so far#returns: string, comprised of letters that represents what #letters have not# yet been guessed. 12345def getAvailableLetters(lettersGuessed): str1 = string.ascii_lowercase for i in range(len(lettersGuessed)): str1 = str1.replace(lettersGuessed[i],"") return str1 Problem 4 - implent the function hangman12345678910111213141516171819202122232425262728Now you will implement the function hangman, which takes one parameterthe secretWord the user is to guess.This starts up an interactive game of Hangman between the user and the computer.Be sure you take advantage of the three helper functions,isWordGuessedgetGuessedWordgetAvailableLetters,that you&apos;ve defined in the previous part.Hints:You should start by noticing where we&apos;re using the provided functions to load the words and pick a random one.Consider using lower() to convert user input to lower case. For example:guess = &apos;A&apos;guessInLowerCase = guess.lower()Consider writing additional helper functions if you need them!There are four important pieces of information you may wish to store:secretWord: The word to guess.lettersGuessed: The letters that have been guessed so far.mistakesMade: The number of incorrect guesses made so far.availableLetters: The letters that may still be guessed.Every time a player guesses a letter, the guessed letter must be removed from availableLetters (and if they guess a letter that is not in availableLetters, you should print a message telling them they&apos;ve already guessed that - so try again!). ​ 这部分给出了一部分辅助代码，主要是从文件中读取单词并随机选取作为 secretWord，然后就是主要游戏部分的设计了。 1234567891011121314151617181920212223242526272829303132333435363738# Hangman game## -----------------------------------# begin of helper codeimport randomWORDLIST_FILENAME = "words.txt"def loadWords(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") inFile = open(WORDLIST_FILENAME, 'r') line = inFile.readline() wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef chooseWord(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code#-----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = loadWords() 1234567891011121314secretWord: string, the secret word to guess.Starts up an interactive game of Hangman.* At the start of the game, let the user know how many letters the secretWord contains.* Ask the user to supply one guess (i.e. letter) per round.* The user should receive feedback immediately after each guess about whether their guess appears in the computers word.* After each round, you should also display to the user the partially guessed word so far, as well as letters that the user has not yet guessed.Follows the other limitations detailed in the problem write-up. 12345678910111213141516171819202122232425262728import stringdef hangman(secretWord): print("Welcome to the game, Hanman!") print("I am thinking of a word that is %d letters long." % len(secretWord)) i = 8 lettersGuessed = list() while(i): print("*"*13) print("You have %d guesses left." % i) print("Available letters:" + getAvailableLetters('')) letter = input("Please guess a letter: ") letter = letter.lower() if letter in lettersGuessed: print("Oops! You've already guessed that letter: "+ getGuessedWord(secretWord, lettersGuessed)) else: lettersGuessed.append(letter) if isWordGuessed(secretWord, lettersGuessed): print("Good guess:" + getGuessedWord(secretWord, lettersGuessed)) if "_" not in getGuessedWord(secretWord, lettersGuessed): print("*"*13) print("Congratulations, you won!") break else: print("Oops! That letter is not in my word:" + getGuessedWord(secretWord, lettersGuessed)) i -= 1 if i == 0: print("*"*13) print("Sorry, you ran out of guesses. The word was %s" % secretWord) 12345# When you've completed your hangman function, uncomment these two lines# and run this file to test! secretWord = chooseWord(loadWords()).lower()hangman(secretWord) ​ 我是在一个 while 函数底下用 if-else 实现，如果字母在已猜字母集中则打印，否则将字母添加到已猜字母集中，如果 isWordGuessed 猜中了，打印，此条件下如果 “_ “ 不在 getGuessedWord 中，打印赢了并 break 退出循环，否则打印字母不在单词中，最后判断一下八次循环结束后仍然没猜出来，打印。 words.txt下载]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之SSB信号接收]]></title>
    <url>%2FGnuradio%E4%B9%8BSSB%E4%BF%A1%E5%8F%B7%E6%8E%A5%E6%94%B6%2F</url>
    <content type="text"><![CDATA[实验目的 学习 GNU Radio 流程图编程。 了解 SSB 信号的接收处理流程， 找到自己需要的模块， 修改模块的参数， 并能根据实验结果分析理论原因。 实验原理 GRC 是基于模块的仿真实验工具。类似于 MATLAB 中的 SIMULINK 工具。基本使用方法就是先将需要用的模块放到窗口。再设置各个模块的参数，然后连接各个模块，绘制信号流程图，之后生成流程图，仿真运行。 实验步骤 1.将数据文件 multi_tx.wav 保存到当前工程目录下。 本例所用 wav 音频信号其采样率为 48KHz，上下边带宽度约 2.6KHz。 2.根据上图创建流程图，文件源设定为保存的数据文件，并将采样率的模块设定为接收信号的采样率 48K。 Float To Complex 将输入数据变为复数，Throttle控制 CPU 占用率，通过 Rational Resample 模块将采样率变为 50K，并将信号幅值扩大 10000 倍，并观察频谱。 3.执行流程图， 当 FFT 显示窗口打开，调节参考平面，使得振幅从 10dB 开始，每格 10dB。 可以观察到一段 50KHz（取决于采样率） 宽度的频谱。同时注意到，在-5KHz~5KHz 内可以看到有信号。 4.数据文件保存的信号载频在基带附近。当 FFT 模块显示后，把坐标移到信号附近，并把信号的左边沿标记，这个值大约为-2.6KHz。由于仅考虑一个下边带（LSB）信号，相当于是基带频率。 因此需要频谱搬移，使 LSB 信号中心频率位于 0 频处。 5.搭建一个接收机的第一步是用一个信道滤波器，作用是保留我们想要的信号，滤去不想要的信号频带。这里，我们需要做的是把想要的信号降频到 0Hz，如图 2 所示。 6.第二步是用一个低通滤波器把其他信号滤除掉 7.在 GRC 中，变频 FIR 滤波器能够完成上述操作。把这个模块插到MultipleyConst 与 AGC2 之间，然后把属性修改为下图所示。 低通滤波器可由 FIR 中的 Taps 实现，具体输入为firdes.low_pass(1,50e3,filter_width/2,300)。其含义为生成一个增益为 1、采样频率 50KHz、截止频率 1.3KHz、变宽 300 的低通滤波器。 tuner 表示下边带频谱， filter_width 表示单边带带宽。 理解为什么中心频率设置为 1.3KHz，可将有用信号搬移到 0 频 中心频率由原来的0变为1.3KHz，相当于整个信号向右平移1.3KHz，把下边带信号放到中心 8.执行流程图，会看到信号被搬移到原点的位置，而且滤除了其它信号。现在我们只定位感兴趣的信号，不关心信号旁边的频谱。可以通过减小采样率来减小信号的频谱范围。再次打开 FIR 滤波器模块，把抽取参数 Decimation 改为5。这时信号的采样率变为 50KHz/5=10KHz。现在看看 FFT 显示的频谱范围有什么变化？ 9.再次执行流程图，检查设置是否正确。信号频谱已被扩展，使用 FFT Plot 中的 Autoscale，信号峰值就可以看到了。观察一段时间可能会看到信号水平会下降几秒，这是因为基站停止发射信号。 10.该信号是个复（解析） 信号。为了解调 SSB 信号，我们需要分别处理其实部和虚部。数据转换模块输入复信号，然后分别输出其实部（上面）和虚部（下面）。把流程图改为所示，数据类型转换模块的输出都是实数，所以 FFT 的数据类型也需要改为 float 类型。 11.执行流程图，可以观察到信号的实部与虚部的频谱。信号被展宽到1.3KHz，也就是低通滤波器的截断频率。 12.我们用 Weaver 法来解调 SSB 信号。 分别对实部与虚部信号按下图进行处理。 使用 GRC 的信号源模块分别产生余弦和正弦信号，相乘器和相加器可以在运算符菜单中找到。 13.在 FFT 窗口观察加法器的输出，这就是从 SSB 信号中解调抽取得到的基带信号。 14.最后一步是收听解调信号。和 AM 电台接收实验类似，增加一个音频模块 Audio Sink，并设置合理的采样率以适应声卡 48KHz 采样率的要求。同时，还需要一个音量控制器 Multiply Const，在信号进入音频模块前降低信号的振幅。当正确配置流程图后，就能听到传输的语音信号。 个人独立完成 SSB 信号的解调和收音工作。 SSB.grc]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之复解析信号特征]]></title>
    <url>%2FGnuradio%E4%B9%8B%E5%A4%8D%E8%A7%A3%E6%9E%90%E4%BF%A1%E5%8F%B7%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[实验目的 学习 GNU Radio 流程图编程。 了解复解析信号的接收处理流程， 找到自己需要的模块， 修改模块的参数， 并能根据实验结果分析理论原因。 实验步骤 1.在 GRC 中打开一个新流程图。 2.按图所示建立一个简单的流程图， 和之前的实验那样给三个 block 的数据类型设定为 float，同时把所有的其它值设定为默认值。 3.执行流程图，打开显示窗口显示一个正弦波，然后测量该信号的幅度和频率是不是之前所设定的。 4.把上述三个框图的类型改为复值，再执行上述流程，显示窗口应该会显示2 个相位互相差 90 度的正弦波。前面的那个波形（来自 Channel 1）为 I（实部）或者称为同相分量，后面的那个波形称之为 Q（虚部）或者正交分量。如果把一个信号源设为复信号，它会同时输出 I 和 Q 分量。 5.修改流程图如图 2 所示，信号源输出设为数据类型为 float 的方波。那么第一个显示窗口和 Throttle 模块都必须设定允许 Float 数据输入。 6.图中的希尔伯特模块可以从滤波器菜单中找到。该模块既可以输出复输入信号的实部，也可以输出其希尔伯特变换的结果。设其默认标签数为 64 个。由于该模块的输出是复值，第二个显示窗口也必须设为可以接收复输入。 7.执行该流程图，打开那两个显示窗口，其一应当为信号源输出的方波，另外一个应该同时包含原方波信号及其希尔伯特变换。能解释为什么方波信号的希尔伯特变换波形是这个样子吗？ 因为希尔伯特变换是将信号与 $\frac{1}{\pi t}$ 进行卷积得到，所以是这样子的。 8.如前第四步所说，信号源可以输出一个复信号，然后在显示窗口显示其实部 I 和虚部 Q。现在把流程图修改为图 3 的设定 9.设定信号源输出复波形，然后确保 Throttle 与显示窗口的数据类型都是复数。执行该流程图，发现这里显示的与希尔伯特变换的结果一样吗？ 不一样 10.新建一个如图流程图，要确保所有模块的类型要设定为 float。该流程图使用 2个余弦信号，频率分别为1KHz和10KHz。让这两个信号相乘，由三角公式我们知道两个余弦信号的积，其结果为频率分别是原信号频率的和与原信号频率的差的合成信号。从频谱图看，应该会得到 9KHz 和 11KHz 的信号输出。 11.执行流程图，然后确认其结果是否与分析的一致。应该注意到 FFT plot模块仅能显示数据类型为 float 的正频谱。我们知道实输入信号的负频谱分量与正频谱分量其实是一样的。 12.把所有模块的数据类型全改为复数，再次执行流程图。你会观察到一个11KHz 频率的信号，这是原信号平移了 1KHz 的结果。 如果你想向相反的方向平移，该怎么做？ 若要向反方向平移，将1kHz的信号频率改成-1kHz，可以通过三角函数设置初始相位使频率为负值 从这个例子中看到两个使用解析信号的优势。一个信号可以在创建一个不同信号的基础上就可以实现频谱平移。 为什么这里没有负频率分量？ 因为现实中频率不能为复数 complex.grc]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之AM电台接收机]]></title>
    <url>%2FGnuradio%E4%B9%8BAM%E7%94%B5%E5%8F%B0%E6%8E%A5%E6%94%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[实验目的学习 GNU Radio 流程图编程。 了解 AM 信号的接收处理流程， 找到自己需要的模块， 修改模块的参数，设计 AM 电台信号接收流程图， 并收听电台内容。 打开 GRC，并连接如图所示数据速率（sample rate）设置为 256K，这是因为保存的文件数据也是 256K。File source 模块中选择已经下载好的文件。选择模块端口输出类型为 complex 为什么在软件无线电中选择复数数据类型？ 在信号处理时用复信号，可以节省一半的带宽 保存并执行上述 FLOW GRAPH，可以观测到该信号的 FFT 频谱，如图所示点击右下角的 Autoscale 按钮可以将波形调整到合适的位置。观测频谱并注意以下几点： （1）因为该信号记录的频点为 710KHz，所以信号的中心频率实际为 710KHz，也就是说图中的 80KHz 的位置实际上是 710K+80K=790KHz。 （2）信号频率展宽范围是-128KHz 到 128KHz。也就是实际的展宽为 256KHz，这与所设置的 Sample Rate 一致。 为了得到分辨率更高的 FFT 频谱，将上图中的频谱展宽如何展宽频谱？ 将 Rational Resampler 模块的加到流程图中，如图 3 所示方法连接，并设置参数Decimation 为 4，其他默认。这样信号的频谱宽度就变为256K/4=64K，如图 所示。 （1） 增加一个 Variable 模块，该模块的作用是灵活的改变参数的设置。例如该步骤中 Sampler Rate需要改为 64K。这里不需要逐一的改编 Throttle、FFT sink中的 Sample Rate 的设置，而只需要将 Variable 的 ID 改为 resamp_factor，然后参数设置为 4，接着在 Throttle 和 FFT 中将参数 Sample Rate 设置为：samp_rate/resamp_factor，这样结果自动计算为 64K。 为了选择中心频率为 710KHz 波段的 AM 电台，需要增加一个低通滤波器去过滤其他信号，参数的设置如图所示 接下来需要做的就是信号解调AM 信号由于是振幅调制信号，即时域波形就是信号的包络。GNU Radio 中包含一个可以将复数信号转为实数信号的模块（Complex to Mag）。流程图如下图所示，执行该流程图就可以观察到 AM 基带信号。尽管 FFT Sink 输入信号类型为 Float 型，但信号频谱只有正频率部分。 （1） 流程图中增加 Throttle 是为了仿真的需要，否则在观察频谱的时候电脑有可能死机。如果信号输入 USRP 设备或者声卡等设备时，则不需要这个模块 接下来就可以收听解调后的 AM 信号了加入 audio sink 和 WX GUI scopesink 模块，流程图如下图所示。（1）目前声卡的采样率大部分为 48K，因此改变 audio sink 中的设置参数。同时，由于 Complex to Mag模块输出的信号采样率为 64K，所以需要通过RationalResampler 模块改变它的输出信号采样率。设置参数 decimate 为 4， interpolate 为3，即采样率为 64K/4*3=48K。 （2）执行该流程图并不能听到真正的 AM 信号，只有”滋滋”的电流声，这是因为输入扬声器的信号功率太大。 加入衰减器 Multiply Const，同时为了能够灵活地调整输入扬声器信号功率，加入 WX GUI Slider模块这个模块的功能像一个滑块，可以灵活地调整变量的值，以便能够调试到合适的参数并收听到 AM 信号， 如图 9 所示。（1）执行该流程，并调整 volume 到 30m 左右，可以听到不是很清楚的声音。这是因为该波段的信号混有噪音，后续会继续进行处理得到清晰的声音。 观察图中的信号可以看到在 80KHz+710KHz 的波段有很强的信号，因此去解调此处的信号为了解调 790KHz 处的信号，需要将其频移至 0 频附近。要想得到该信号，可以通过乘以一个余弦信号进行频谱的搬移。修改频谱后如图 10 所示： （1）时域信号相乘相当于频域的相加。因此乘以-80KHz 的余弦波可以将信号往左搬移 80KHz。 为什么可以这样操作？ 原理为三角函数里面的和差化积公式 （2）可以增加一个 WX GUI Slider 去调节所加信号的频率，实现的对电台（频率）的可选择性。 （3）执行该流程图可以听到比较清新的声音，但仍有很多杂音，这是由于电噪声的影响。可以通过增益自动调节模块（AGC）来进行调节。 增加自动增益控制模块（AGC2）及调节频率的 slider 模块，得到如图所示的结果（1） AGC2 模块加到 Low pass filter 和 Complex to Mag 模块之间 （2） AGC2 模块参数设置： Attack=6.25e-4, Decay=1e-5。其他默认 （3）声卡可接收的功率范围是-1.0 到 1.0 （4）执行流程图，调整余弦信号频率到-80KHz，可以听到比较清晰的声音，然后调节 volume，可以增大音量。这时听到的声音比前面的要清新多了。 （5）当所观测的 FFT GUI 界面有两个以上时，可以用 WX GUI Notebook 模块。该模块可以产生如图中所示的 tab1 tab2 tab3 标签样式。 可以很清晰的听出原文是一段英文 电台文件下载]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之ASK信号的调制与解调]]></title>
    <url>%2FGnuradio%E4%B9%8BASK%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83%2F</url>
    <content type="text"><![CDATA[实验目的​ 学习 GNU Radio 流程图编程。 了解 ASK 信号的发送和接收处理流程， 找到自己需要的模块， 修改模块的参数，设计 ASK 信号发送接收流程图 实验步骤​ 利用幅度键控 ASK 理论，在 GNU Radio 环境下完成了 ASK 调制信号的产生和解调。整个流图如下： ​ 第一个相乘器后产生的即 ask 信号，利用高频载波与调制信号相乘产生，其中调制信号中设置了高斯白噪声。经过传输特性为带通的信道传输。解调电路采用相干解调，由 ask 信号与原来的载波进行相乘，然后经过低通滤波，这里的门限值分别为0.1 和 0.5，不同的值对最后的影响主要是占空比和时延。最后由脉冲抽样电路完成原来数字调制信号的恢复。 原始调制信号 产生的 ask 信号波形和频谱 经过低通滤波器后的波形与频谱 最后解调的结果 与原始信号对比，为什么有延迟和占空比的变化？ 因为信号经过低通滤波器，滤波器的门限值影响延迟和占空比]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之AM-DSB-LSB实现]]></title>
    <url>%2FGnuradio%E4%B9%8BAM-DSB-LSB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实验目的利用模拟幅度调制理论知识和 GNURadio 流图设计方法，独立搭建模拟幅度调制设计方案，实现： AM 调制和控制调幅指数 DSB 调制和解调 LSB 调制和解调 并通过仿真结果验证其频谱的正确性。 实验原理通过控制载波、设置合理的滤波器，来观察幅度调制信号的频谱变化情况。 实验步骤可能使用的模块有”Signal Source、 Multiply Const（乘以常系数）、Add Const（加常系数） 、 Multiply、 Throttle、 WX GUI FFT Sink、 Low Pass Filter、 WX GUI Scope Sink”。 余弦调制信号频率： 200Hz； 载频： 1000Hz； 采样率； 5000Hz 放大系数 Ac： 0.35 AM 调制和控制调幅指数1.产生常规 AM 调制信号，观察频谱变化；利用 Slider 模块，调整调幅指数，观察时域波形变化。 根据公式画出上图，m(t)信号先加常系数1，再与载频信号相乘，再乘slider模块控制的常系数，最后画出时域图(频域图) DSB 调制与解调 解调 DSB 信号： 发送信号频谱： DSB 调制信号频谱： 解调后信号频谱： LSB 调制与解调$$S_{\text{SSB}}\left( t \right) = \frac{1}{2}A_{c}m\left( t \right)cos2\pi f_{c}t \mp \frac{1}{2}A_{c}m\hat{}\left( t \right)sin2\pi f_{c}t$$ 在本实验中，信号源为$m\left( t \right) = \cos\left( 2pi200*t \right)$ 其希尔伯特变换为$m\hat{}(t) = sin(2pi200*t)$ 按下图产生下边带信号 解调LSB信号： LSB 调制信号频谱： 解调信号频谱： AM文件下载DSB文件下载LSB文件下载]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4G-LTE测试分析]]></title>
    <url>%2F4G-LTE%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[LTEInspector: A Systematic Approach for Adversarial Testing of 4G LTE]The Attack Focus On: A-4 Authentication Relay Attack ​ 4G在我们的印象中是一个非常安全的协议，包括即将进入商用阶段的5G协议应该会更加的安全。但是实际情况的并不是如此，普渡大学的几位研究人员发现了4G协议依旧存在着很多的漏洞（已经发现了十个漏洞，其中的七个漏洞已经被验证，一个部分被验证，还有两个等待验证），部分漏洞对5G协议而言依旧是存在的。3GPP曾经讨论过在5G引入证书体系，防止手机连接恶意节点。就是说恶意节点发出的广播消息都要携带签名，手机终端能识别出来哪些是恶意节点，于是就不会尝试连接，连初始连接的第一条消息都不会发出。但是大部分运营商和设备厂商都认为这个方案太”重”了，没有采用，可能6G的时候还会再讨论。 ​ 在这次发布的十个漏洞中，有六个漏洞可以归结为拒绝服务攻击（A-1、A-3、P-1、P-2、P-4、P-5），DoS 类攻击，是长期无法解决的问题，即使在5G系统中，仍然有一些不能解决。在这篇研究报告中研究人员为我们介绍了十种4G LTE的漏洞，这些漏洞分别是基于4G LTE三个工作阶段而发现的：连接环节、寻呼环节和分离环节。而在这其中，连接环节无疑是相对复杂与重要的一个环节。 I.LTE预备​ 在论文中，作者为了方便解释他们的工作成果，将LTE网路架构进行了简化：只关注它有关附着、去附着和寻呼过程的部分。为了更好理解鉴权中继攻击的过程，我们首先学习了作者简化过的 4G LTE，并摘取其中与我们讨论相关的内容： Part One.LTE网络架构 ​ LTE网络大体上由以下三部分组成：蜂窝网络设备（也被称作用户设备或者UE）；无线电接入网（E-UTRAN）；核心网络（EPC）。 UE：UE是装备了用户身份识别卡（SIM卡）的蜂窝网络设备。SIM卡安全地储存了国际移动用户识别码（IMSI），还有用于UE和EPC通信初始化时注册和鉴权的密钥。UE本身也有唯一的设备身份：国际移动设备识别码（IMEI），它也用来注册。暴漏 IMSI/IMEI后，UE有可能被非法追踪或假冒，所以说它们是非常敏感的信息。EPC：EPC 中有两个与我们讨论内容相关的实体：MME 和 HSS。 ⑴ Mobility Management Entity: MME 管理一个跟踪区（它由一组六边形的小区构成）中的UE的附着（包括鉴权和密钥协商）,寻呼和去附着过程。它还负责记录其跟踪区中UE的位置，方便寻呼过程。 ⑵ Home Subscriber Server：HSS 储存各 UE 的 IMSI/IMEI、用户信息（如 QoS 文件）和主密钥。它会用UE的主密钥产生鉴权挑战和对称会话密钥。 Part Two.附着过程 ​ 当一个UE想要连接EPC时（比如说在它重启之后），它首先搜索附近 eNB 广播的系统信息块 (SIB) 之后，UE 会和收到的信号功率最高的 eNB 建立连接。在后文我们会讲到，这一特点能被鉴权中继攻击利用。一旦 UE 与 eNB 建立好连接，附着过程就可以根据以下步骤进行： A.注册：附着过程的第一步，是 UE 通过 eNB 向 MME 发送 attach_request 。attach_request 中用明文包含了 UE 的身份（IMSI/IMEI）和它的安全能力(比如它支持的密码算法套件）。 B.鉴权：MME 在收到 UE 的注册请求后，向用户的 HSS 发送其 IMSI，请求对该用户身份进行认证，HSS会给MME回复 authentication_challenge。之后，MME给UE发送包含 authentication_challenge 的 authentication_request。UE在收到鉴权请求后，用它的主密钥来解 authentication_challenge，并回复authentication\response 给 MME。只有鉴权过程成功了，UE 和 MME 才能进入能下一阶段。 C.安全算法协商:在注册过程中，UE 发送的 attach_request 包含了它的安全能力，于是 MME 能够挑选一对 UE 支持的加密算法和完整性保护算法。首先，MME 发送完整性保护的 security_mode_command 给 UE，其中重放了之前 UE 发来的安全能力,这是为了让 UE 验证 security_mode_command 中的安全能力是否与其发送的attach_request 中的一致。成功验证包含在 security_mode_command 中的消息认证码（MAC）后，UE 回复经过加密并有完整性保护的 security_mode_complete 给MME。至此，UE 和 MME 成功创建了保护未来通信机密和完整性的共享安全上下文，即共享密钥。 D.安全临时标识符交换：MME 向 UE 发送一条经加密且有完整性保护的attach_accept，其中包含了一个临时标识，即 GUTI(Globally Unique Temporary Identity)，用于此后的所有的 UE 与 eNB/MME 之间的通信。其目的是为了减少IMSI/IMEI 泄露的可能。收到这条信息后，UE 回复 attach_complete，结束附着过程。附着完成后，UE 和 eNB 之间也会产生一对共享密钥，给它们之间的通信创建安全上下文。 上面大致介绍了 4G 工作过程中的附着阶段，在这里我们可以对这三个过程做一个总结：第一个环节是连接环节，也就是将用户设备与网络相关联的过程（例如，用户打开手机）；第二个环节是寻呼环节，该环节是建立呼叫的一部分，通常用于强制设备重新获取系统信息，并用于紧急警报；最后一个环节是分离环节，用户关闭设备，网络会与设备断开连接的过程（又如，由于信号质量差无法进行网络验证）。 II.鉴权中继攻击​ 在了解了这十种攻击之后，发现其中的两种攻击最有研究价值：其中的一个攻击是 A-4 鉴权中继攻击，这种手法可以伪造手机在网络中的位置（这个是可以被个人利用的），相当于手机与真实网络中间加了两个中继器，真实网络只知道中继器在哪里，不知道手机在哪里。这样，即使该用户在西安也可以将位置信息变成北京，形成完美的不在场证明；剩下的一种攻击是P-3发送假的灾害警报，例如18年1月份的时候夏威夷有一个虚假导弹袭击的警报，就是基于这种原理实现的。 i.攻击过程描述 实施鉴权中继攻击中，可以分为以下两个步骤：I. 断开受害者设备 $\text{UE}{\text{vic}}$ 与核心网EPC之间的连接；II.攻击者设备 $\text{UE}{\text{adv}}$ 伪装成受害者设备 $UE_{\text{vic}}$ 接入到核心网EPC中。 为了断开受害者设备 $\text{UE}_{\text{vic}}$ 与核心网 EPC 之间的连接，可以利用研究人发现的其他漏洞来达成这一目标。例如 D-1 降级攻击就可以完成此步骤，在假设中攻击者知道了受害者设备的 IMSI，所以为了能够精准的攻击，攻击者会通过恶意的 eNodeB广播发送 identity_request，UE 实体收到此条消息后，会向 eNodeB 回复包含自己的 IMSI 的 identity_response。此时，如果受害者刚好在其中的话，那么攻击者就可以向该受害者设备 $\text{UE}_{\text{vic}}$ 发送 detach_request，至此完成了中继攻击的第一个步骤。 受害者设备 $\text{UE}{\text{vic}}$ 这时会尝试着与信号最强的 eNodeB 建立连接—此时的信号最强的 eNodeB 是 ${eN\text{ode}B}{\text{adv}}$，受害者终端 $E_{\text{vic}}$ 会向 ${eN\text{ode}B}_{\text{adv}}$ 发送附着请求(attach_request) 的消息 $m_{\text{re}}$，接着 ${eN\text{ode}B}{\text{adv}}$ 会将此附着请求消息 $m{\text{re}}$ 转发给攻击者设备 $\text{UE}{\text{adv}}$，由 $\text{UE}{\text{adv}}$ 将 $m_{\text{re}}$ 向正常节点 ${eN\text{ode}B}{\text{ben}\text{gin}}$ 转发。当合法的 MME 收到连接请求 $m{\text{re}}$后，就会通过正常节点 ${eN\text{ode}B}{\text{ben}\text{gin}}$ 向攻击者设备发送认证挑战 c。当然，攻击者设备是没有能力去解决这个认证挑战,它会通过恶意的节点${eN\text{ode}B}{\text{adv}}$ 将此认证挑战 c 转发给受害者设备 $\text{UE}{\text{vic}}$。受害者设备 $\text{UE}{\text{vic}}$ 收到认证挑战 c 后，它并没有意识到整个过程中发生了什么，它以为这是一个正常的节点发送过来的挑战 c，因此它会将挑战 c 解开，将结果 r 发送给恶意的节点 ${eN\text{ode}B}{\text{adv}}$，和刚开始的附着请求的消息过程一致，恶意的节点 ${eN\text{ode}B}{\text{adv}}$会将结果 r 转发给恶意设备 $\text{UE}{\text{adv}}$，由恶意设备$\text{UE}{\text{adv}}$将结果 r 提交给节点 ${eN\text{ode}B}_{\text{ben}\text{gin}}$，由该节点将结果r发送给 MME。对于附着过程中的剩下步骤，使用和上面请求认证和验证挑战两步一样的原理，攻击者设备就可以冒充并使用另一方的身份接上网络。 ii.攻击原理 鉴权中继攻击，只能伪造手机的位置，手机的完整性保护和加密保护仍然是没有攻破的，中继器不能解出手机发送的数据内容（除非运行商公然忽视了安全标准的推荐，选择在连接建立阶段使用若安全性或者是无安全性文本传输）。在中继攻击中，破坏的是信息传输的认证性，因为在正常设备和正常节点的信息通路中，加入了一个恶意节点和恶意设备，正常设备不知道自己收到的信息是恶意节点转发的，同理，正常节点也不知道自己收到的信息是恶意设备转发正常设备的。 iii.攻击可能带来的影响 在研究人员的论文中，他们还提到了鉴权中继攻击会带来的影响。因为恶意设备和节点会将受害者设备的一切发送与接受的信息进行转发，所以攻击者可以对受害者发动拒绝服务攻击（例如，将受害者的文件传输、电话等信息不进行转发，因此受害者此部分的服务因此就不能实现了）。同样地， 攻击者可以根据转发的数据大致的勾勒出受害者使用的习惯、模式等隐私信息。最重要的是，这种方法可以伪造手机在网络中的位置。因为攻击者设备$\text{UE}{\text{adv}}$无需和受害者设备$\text{UE}{\text{vic}}$在同一片追踪区域，因此$\text{UE}{\text{adv}}$可以从另外的区域向核心网 EPC鉴定自己，由此受害者设备$\text{UE}{\text{vic}}$的位置信息历史也会受到误导(在核心网EPC那边来看，真正连入的设备只有$\text{UE}{\text{vic}}$，会存储有关的信息，例如：$\text{UE}{\text{vic}}$的 IMSI、IMEI 等信息，而$\text{UE}{\text{adv}}$发送的位置信息因此也会被误认为是$\text{UE}{\text{vic}}$的位置信息)。 III.其他攻击 在鉴权中继攻击中，第一步需要实施的工作是将受害者设备$\text{UE}_{\text{vic}}$与核心网核心网EPC断开连接，论文中，研究人员给我们介绍了三种攻击可以作为鉴权中继攻击的前奏。 i.A-3 麻木攻击 麻木攻击可使攻击者注入乱序控制层协议消息，中断受害用户手机服务，只有重启手机才能恢复。该攻击可与其他攻击联合使用，让攻击者能够冒充受害者行骗。从攻击的性质上来说，麻木攻击是一种拒绝服务攻击。 根据协议标准，网间传递的消息 auth_reject 不受加密保护，因此一旦受害设备UE连接到恶意节点 eNodeB，恶意节点就可以向受害设备注入拒绝验证消息auth_reject。受害设备 UE 一接收到 auth_reject 消息后，它首先会将自己从网络中去附着，完全关闭所有蜂窝活动，甚至不尝试降级或者连接到 3G / 2G 网络。 这种情况下，即使重新插入 SIM 卡也不允许受害者 UE 重新与核心网 EPC 连接。而为了能够重新接入网络，受害者必须将他的设备 UE 重新启动方可。 ii.P-2 隐身开启攻击 在劫持受害者 UE 寻呼信道后，恶意节点可以创建一条寻呼信息，其中一条寻呼记录由受害者 UE 的 IMSI 组成，寻呼记录的其他字段设置为与原始寻呼信息类似。接收到带有 IMSI 的寻呼信息后，受害者 UE 发现它自己的 IMSI 在第一个寻呼记录中。所以，它会将自己从核心分组网中断开，然后发送请求附着的消息。这种攻击会使得受害手机断开与 EPC 的连接，所以可以将这种攻击作为鉴权中继攻击的前奏之一。 iii.D-1 去附着/降级攻击 降级攻击的过程和麻木攻击的过程是十分类似的，攻击者可以在网络中向某一受害者 UE 注入消息 detach_request，可以强制该受害者 UE 从网络中断开。 此外，为了实施这种攻击，需要知道受害者 UE 的 IMSI。因此，研究人员在报告中说到，可以先通过恶意节点 eNodeB 广播消息 identity_request， UE 收到后会回复包含自身 IMSI 的消息 identity_response 给恶意节点，攻击者就可以得到 UE 的 IMSI。 IV.参考论文与链接[1] Syed Rafiul Hussain，Omar Ch-wdhury，Shagufta Mehnaz, Elisa Ber-Tino,” LTEInspector: A Systematic Approach for Adversarial Testing of 4G LTE”,Feb .2018 [2] “对LTE Inspector论文的一些解读”，https://unicorn.360.com/blog/2018/03/09/Interpretation_of_LTE_Inspector_Papers [3] “研究人员发现4G LTE网络协议漏洞”， https://www.freebuf.com/news/164109.html [4] “从追踪到劫持 研究人员发现十个 4G LTE 漏洞”, https://www.aqniu.com/hack-geek/31968.html]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>无线网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop部署]]></title>
    <url>%2FHadoop%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[环境Ubuntu 14.04.5 x64Hadoop 2.x.y Hadoop 有两个主要版本，Hadoop 1.x.y 和 Hadoop 2.x.y 系列，比较老的教材上用的可能是 0.20 这样的版本。Hadoop 2.x 版本在不断更新，本教程均可适用。如果需安装 0.20，1.2.1这样的版本，也可以作为参考，主要差别在于配置项 创建Hadoop用户(创建新用户是为了改环境的时候更方便一点)ctrl+alt+t打开终端 命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shellsudo useradd -m hadoop -s /bin/bash 设置密码sudo passwd hadoop 部署管理员权限sudo adduser hadoop sudo su hadoop切换用户 更新一下aptsudo apt-get update //sudo apt-get install vim 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：sudo apt-get install openssh-server ssh localhost 首次登录提示输入yes看到hadoop@hadoop-Practise：即可确定登录成功 exit退出用ssh-keygen生成密钥 1234exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如用户名为 hadoop，则 ~ 代表 “/home/hadoop/ 此时ssh localhost命令无需密码即可登录 安装Java环境sudo apt-get install openjdk-7-jre openjdk-7-jdkJava环境可选择 Oracle 的 JDK，或是 OpenJDK，OpenJDK 1.7 是没问题的。为方便，这边直接通过命令安装 OpenJDK 7（http://wiki.apache.org/hadoop/HadoopJavaVersions ） 安装好 OpenJDK 后，需要找到相应的安装路径，这个路径是用于配置JAVA_HOME 环境变量的。执行如下命令：dpkg -L openjdk-7-jdk | grep ‘/bin/javac’ 该命令会输出一个路径，除去路径末尾的 “/bin/javac”，剩下的就是正确的路径了。如输出路径为 /usr/lib/jvm/java-7-openjdk-amd64/bin/javac，则我们需要的路径为 /usr/lib/jvm/java-7-openjdk-amd64。 接着配置 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置vim ~/.bashrc source ~/.bashrc #使变量设置生效 echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样则Hadoop 所需的 Java 环境安装完成 安装 Hadoop 2（）在root用户的/usr/local/目录下下载hadoop-2.6.0.tar.gz文件wget https://archive.apache.org/dist/hadoop/core/hadoop-2.6.0/hadoop-2.6.0.tar.gz tar hadoop-2.6.0.tar.gz 解压安装包mv hadoop-2.6.0 hadoop 将安装目录由hadoop-2.6.0改为hadoop chown -R hadoop hadoop 将hadoop目录的拥有者设为hadoop用户-R : 对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更) 虽然Hadoop安装在/usr/local中，也是针对所有用户的，但是我们用账户hadoop来进行整个测试，所以更改文件权限不能不做，否则，在后面./sbin/start-dfs.sh步会遇到no such file or directory等错误 使用如下命令查看是否安装成功cd /usr/local/hadoop./bin/hadoop version 至此，hadoop安装成功 单机模式Hadoop本地模式只是用于本地开发调试，或者快速安装体验Hadoop 打开/usr/local/hadoop/etc/hadoop/hadoop-env.sh 将export JAVAHOME=${JAVAHOME}修改为export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64#视Java安装位置而定 (java的安装路径可用echo $JAVA_HOME查询) export HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:/usr/local/hadoop/bin 然后source hadoop-env.sh以保存修改此时单机模式就已配置完成。 单机模式测试采用Hadoop自带的示例WordCount来测试单机模式是否安装成功在/usr/local/hadoop路径下创input目录然后将README.txt文件拷贝到input目录中，然后执行 1bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.7.3-sources.jar org.apache.hadoop.examples.WordCount input output 输出结果如下： 即可说明单机模式配置成功！ 打开output目录下的part 00000文件可以看到每个词的出现次数，实现了词频统计 伪分布式模式学习Hadoop一般是在伪分布式模式下进行。这种模式是在一台机器上各个进程上运行Hadoop的各个模块，伪分布式的意思是虽然各个模块是在各个进程上分开运行的，但是只是运行在一个操作系统上的，并不是真正的分布式。 沿用单机模式的配置，再修改core-site.xml和hafs-site.xml两个文件vim /usr/local/hadoop/etc/hadoop/core-site.xml原本文件中是如下内容 添加成如下内容： hadoop.tmp.dir file:/usr/local/hadoop/tmp Abase for other temporary directories. fs.defaultFS hdfs://localhost:9000 vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml添加成如下内容： dfs.replication 1 dfs.namenode.name.dir file:/usr/local/hadoop/tmp/dfs/name dfs.datanode.data.dir file:/usr/local/hadoop/tmp/dfs/data 注意，如果要变回单机模式，清空&lt;configuration&gt;标签中的内容即可。 且如果不是以YARN模式启动的话，无需配置mapred-site.xml。 格式化 namenode 在/usr/local/hadoop目录下以hadoop用户执行./bin/hdfs namenode -format 如上说明格式化namenode成功 ./sbin/start-dfs.sh 启动服务可以看到 用jps命令判断是否启动成功 如上，启动成功！ 若无Datanode和Namenode,说明配置不成功，针对这种情况，依次执行一下命令 1234./sbin/stop-dfs.sh # 关闭dfsrm -r ./tmp # 删除 tmp 文件，注意这会删除 HDFS 中原有的所有数据./bin/hdfs namenode -format # 重新格式化 NameNode./sbin/start-dfs.sh # 重启dfs 若 jps 命令’command not found’ ，由于jps是jdk自带的命令，找不到命令可能环境变量出了问题，用echo $PATH 查看环境变量，若无，则在hadoop用户的根目录下的./bashrc文件中配置JAVA的环境变量 export JAVA_HOME=/java的安装路径/export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 然后source ./bashrc 保存应用即可 启动成功后可以打开http://localhost:50070管理页面查看namenode和datanode或者DFS信息（云服务器可以打开http://服务器地址:50070/） 伪分布模式测试单机模式直接读取的是本地文件，如input目录和output目录，而伪分布式模式需要读取分布式文件系统HDFS中的文件，所以还得先建立HDFS。 ./bin/hdfs dfs -mkdir -p /user/hadoop # 在HDFS中创建用户目录./bin/hdfs dfs -mkdir input # 在用户目录下创建input目录./bin/hdfs dfs -put ./etc/hadoop/*.xml input # 将一些测试文件移入input目录，就移配置xml文件作为输入 （相对路径input即可表示/user/hadoop/input） 然后执行一个筛出dfs开头的单词的程序： 其中./bin/hadoop jar向集群提交作业 grep是Hadoop提供的一个示例程序 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output ‘dfs[a-z.]+’ 查看输出，此时输出仍在HDFS中 可以将HDFS中的文件拷到本地./bin/hdfs dfs -get output ./output 注意第二次运行的时候需要删除HDFS中的output，否则会报错，因为此中有防止覆盖的机制，不会在你在不知情的情况下就覆盖掉上一个output。 最后所有程序运行结束后运行./sbin/stop-dfs.sh停止守护进程即可 wordcount测试 先删除HDFS中的output目录：./bin/hdfs dfs -rm -r output 然后如同单机模式中运行WordCount程序一样，运行：bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar org.apache.hadoop.examples.WordCount input output 完全分布模式完全分布式模式才是生产环境采用的模式，Hadoop运行在服务器集群上，生产环境一般都会做HA，以实现高可用 HA安装HA是指高可用，为了解决Hadoop单点故障问题，生产环境一般都做HA部署。]]></content>
      <categories>
        <category>云计算与大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 内核编译与系统调用]]></title>
    <url>%2FLinux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[任务​ 编译内核​ 增加一个系统调用 CentOS 上编译内核 V4.10.1，并添加一个系统调用 xz 格式文件如何创建和解压.xz 格式文件？以解压linux-3.12.tar.xz为例 解压 xz 格式文件 首先用 xz-utils 的 xz 命令将 linux-4.18.15.tar.xz 解压为 linux-4.18.15.tar其次用 tar 命令将 linux-4.18.15.tar 完全解压 123xz –d linux-4.18.15.tar.xztar –xf linux-4.18.15.tar或 tar –Jxf linux-4.18.15.tar.xz 创建 xz 格式文件 首先利用 tar 命令将 linux-4.18.15 文件夹打包成 linux-4.18.15.tar其次用 xz-utils 的 xz 命令将 linux-4.18.15.tar 压缩成 linux-4.18.15.tar.xz 123tar –cf linux-4.18.15.tar linux-4.18.15/xz –z linux-4.18.15.tar或 tar –Jcf linux-4.18.15.tar.xz linux-4.18.15/ Linux 内核编译首先用 cat /etc/redhat-release 和 uname -msr 命令查看当前系统的内核情况 发现是 CentOS 系统，用 yum 安装一些需要的编译工具 12yum updateyum install –y ncurses-devel make gcc bc bison flex elfutils-libelf-devel openssl-devel grub2 cd /usr/src 进入 /src 目录底下准备下载想要编译的内核文件 这里我选用最新的稳定版本 4.18.15 tar.xz 文件解压后进入目录 cp /boot/config-$(uname -r) .config 复制当前正在运行的内核的配置文件 make menuconfig 可以配置 Linux 内核 由于我们刚刚复制了正在运行的配置，所以可以直接退出不用管它 查看计算机配置并编译 确保编译命令在 /usr/src/linux-4.18.15目录下执行 12345make bzImagemake modulesmakemake modules_installmake install 编译时若遇见 gcc: Internal error: Killed (program cc1) 错误，是因为编译过程需要大量的内存，可以开启 swap 分区继续编译 编译完成后 reboot 命令重启服务器 重启后查看发现内核版本号不对 找到配置文件 /boot/grub/grub.conf，可以看到 default=1 默认启动的内核是CentOS (2.6.32-754.6.3.el6.x86_64) 将 default 值置为 0 并重启 如上图所示，内核替换成功 添加新的系统调用先查看一下系统的调用表 vim /usr/src/linux4.18.15/arch/x86/entry/syscalls/syscall_64.tbl 在文件末端添加自己的系统调用函数以及对应的系统调用编号(335为本文添加) vim include/linux/syscalls.h 在末端加入系统调用函数的声明 vim kernel/sys.c 文件末端加入对应的实现函数 123456make oldconfig //一直按回车即可make –j4 //4指多线程编译的个数make modules_install make install rebootuname -sr 编写一个简单的 test.c 的文件并编译 cat /proc/kallsyms | grep mysyscall 确认调用新的系统函数 新版本内核中的系统函数 include/linux/syscalls.h 文件以及 kernel/sys.c 文件都有了一些变动 之前以为没有影响用dmesg命令查看编译结果结果最后的发现i溢出了 最后决定选用4.10.14版本的内核重复上述过程 编译完成后，编写 test.c 文件测试 ./out 执行生成文件 用 demsg 查看结果 调用成功！ 报错汇总编译模块环节遇到了错误 经查询发现编译过程中内存耗尽, 导致了编译中断，可能是系统没有交换分区, 解决方法是增加一个交换分区 创建分区文件, 大小 2G dd if=/dev/zero of=/swapfile bs=1k count=2048000 生成 swap 文件系统 mkswap /swapfile 激活 swap 文件 swapon /swapfile 这样就木有问题了, 但是这样并不能在系统重启的时候自动挂载交换分区, 这样我们就需要修改 /etc/fstab 文件, 新增如下内容: /swapfile swap swap defaults 0 0 could not find moudle 错误 在make install时，为了让新内核中不缺少所需module，会先检查当前系统已经加载了的module（lsmod命令可查看），然后对比新安装的内核模块，如果新的内核模块中缺少一些module（和当前lsmod命令的输出做对比），就会报 ERROR: modinfo: could not find module power_meter 这样的错误信息。 具体来说，缺少相应module而报错，大致可分为3种情况： 确实是缺少了某个 module，其解决方法是：如果报的 module 对于你来说是有用，检查编译 kernel 时的 .config 文件，加上对应的配置（配为=m），重新编译和安装 modules 即可；如果你觉得这个module没啥用，就不必管它。 新编译的 kernel 已经将该选项编译进 kernel 了（.config中选择为=Y），从而不需要生成这个 module的 .ko 文件，系统找不到对应的 .ko文件，但是已经在新内核中了，不必理会这个报错。 模块的名称变了，用当前系统 lsmod 命令查找的模块名称，在新编译的内核中找不到 module 了。只需要检查确认即可，如这里的 ERROR: modinfo: could not find module power_meter 就是这种类型，检查方式如下： 最后，如果那些错误报的内核模块，你认为不重要或者都经过上面的分析解决后，你就可以忽略这些错误提示了；尽管有这些 ERROR: modinfo: 错误提示，但是 kernel 还是被正确安装了的，往下继续操作使用即可。 参考链接： https://brennan.io/2016/11/14/kernel-dev-ep3/https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
