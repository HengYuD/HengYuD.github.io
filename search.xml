<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gnuradio之复解析信号特征]]></title>
    <url>%2F2019%2F04%2F23%2FGnuradio%E4%B9%8B%E5%A4%8D%E8%A7%A3%E6%9E%90%E4%BF%A1%E5%8F%B7%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[实验目的： 学习 GNU Radio 流程图编程。 了解复解析信号的接收处理流程， 找到自己需要的模块， 修改模块的参数， 并能根据实验结果分析理论原因。 实验步骤： 1.在 GRC 中打开一个新流程图。 2.按图所示建立一个简单的流程图， 和之前的实验那样给三个 block 的数据类型设定为 float，同时把所有的其它值设定为默认值。 3.执行流程图，打开显示窗口显示一个正弦波，然后测量该信号的幅度和频率是不是之前所设定的。 4.把上述三个框图的类型改为复值，再执行上述流程，显示窗口应该会显示2 个相位互相差 90 度的正弦波。前面的那个波形（来自 Channel 1）为 I（实部）或者称为同相分量，后面的那个波形称之为 Q（虚部）或者正交分量。如果把一个信号源设为复信号，它会同时输出 I 和 Q 分量。 5.修改流程图如图 2 所示，信号源输出设为数据类型为 float 的方波。那么第一个显示窗口和 Throttle 模块都必须设定允许 Float 数据输入。 6.图中的希尔伯特模块可以从滤波器菜单中找到。该模块既可以输出复输入信号的实部，也可以输出其希尔伯特变换的结果。设其默认标签数为 64 个。由于该模块的输出是复值，第二个显示窗口也必须设为可以接收复输入。 7.执行该流程图，打开那两个显示窗口，其一应当为信号源输出的方波，另外一个应该同时包含原方波信号及其希尔伯特变换。能解释为什么方波信号的希尔伯特变换波形是这个样子吗？ 因为希尔伯特变换是将信号与 $\frac{1}{\pi t}$ 进行卷积得到，所以是这样子的。 8.如前第四步所说，信号源可以输出一个复信号，然后在显示窗口显示其实部 I 和虚部 Q。现在把流程图修改为图 3 的设定 9.设定信号源输出复波形，然后确保 Throttle 与显示窗口的数据类型都是复数。执行该流程图，发现这里显示的与希尔伯特变换的结果一样吗？ 不一样 10.新建一个如图流程图，要确保所有模块的类型要设定为 float。该流程图使用 2个余弦信号，频率分别为1KHz和10KHz。让这两个信号相乘，由三角公式我们知道两个余弦信号的积，其结果为频率分别是原信号频率的和与原信号频率的差的合成信号。从频谱图看，应该会得到 9KHz 和 11KHz 的信号输出。 11.执行流程图，然后确认其结果是否与分析的一致。应该注意到 FFT plot模块仅能显示数据类型为 float 的正频谱。我们知道实输入信号的负频谱分量与正频谱分量其实是一样的。 12.把所有模块的数据类型全改为复数，再次执行流程图。你会观察到一个11KHz 频率的信号，这是原信号平移了 1KHz 的结果。 如果你想向相反的方向平移，该怎么做？ 若要向反方向平移，将1kHz的信号频率改成-1kHz，可以通过三角函数设置初始相位使频率为负值 从这个例子中看到两个使用解析信号的优势。一个信号可以在创建一个不同信号的基础上就可以实现频谱平移。 为什么这里没有负频率分量？ 因为现实中频率不能为复数 complex.grc]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之AM电台接收机]]></title>
    <url>%2F2019%2F04%2F23%2FGnuradio%E4%B9%8BAM%E7%94%B5%E5%8F%B0%E6%8E%A5%E6%94%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[实验目的学习 GNU Radio 流程图编程。 了解 AM 信号的接收处理流程， 找到自己需要的模块， 修改模块的参数，设计 AM 电台信号接收流程图， 并收听电台内容。 打开 GRC，并连接如图所示数据速率（sample rate）设置为 256K，这是因为保存的文件数据也是 256K。File source 模块中选择已经下载好的文件。选择模块端口输出类型为 complex 为什么在软件无线电中选择复数数据类型？ 在信号处理时用复信号，可以节省一半的带宽 保存并执行上述 FLOW GRAPH，可以观测到该信号的 FFT 频谱，如图所示点击右下角的 Autoscale 按钮可以将波形调整到合适的位置。观测频谱并注意以下几点： （1）因为该信号记录的频点为 710KHz，所以信号的中心频率实际为 710KHz，也就是说图中的 80KHz 的位置实际上是 710K+80K=790KHz。 （2）信号频率展宽范围是-128KHz 到 128KHz。也就是实际的展宽为 256KHz，这与所设置的 Sample Rate 一致。 为了得到分辨率更高的 FFT 频谱，将上图中的频谱展宽如何展宽频谱？ 将 Rational Resampler 模块的加到流程图中，如图 3 所示方法连接，并设置参数Decimation 为 4，其他默认。这样信号的频谱宽度就变为256K/4=64K，如图 所示。 （1） 增加一个 Variable 模块，该模块的作用是灵活的改变参数的设置。例如该步骤中 Sampler Rate需要改为 64K。这里不需要逐一的改编 Throttle、FFT sink中的 Sample Rate 的设置，而只需要将 Variable 的 ID 改为 resamp_factor，然后参数设置为 4，接着在 Throttle 和 FFT 中将参数 Sample Rate 设置为：samp_rate/resamp_factor，这样结果自动计算为 64K。 为了选择中心频率为 710KHz 波段的 AM 电台，需要增加一个低通滤波器去过滤其他信号，参数的设置如图所示 接下来需要做的就是信号解调AM 信号由于是振幅调制信号，即时域波形就是信号的包络。GNU Radio 中包含一个可以将复数信号转为实数信号的模块（Complex to Mag）。流程图如下图所示，执行该流程图就可以观察到 AM 基带信号。尽管 FFT Sink 输入信号类型为 Float 型，但信号频谱只有正频率部分。 （1） 流程图中增加 Throttle 是为了仿真的需要，否则在观察频谱的时候电脑有可能死机。如果信号输入 USRP 设备或者声卡等设备时，则不需要这个模块 接下来就可以收听解调后的 AM 信号了加入 audio sink 和 WX GUI scopesink 模块，流程图如下图所示。（1）目前声卡的采样率大部分为 48K，因此改变 audio sink 中的设置参数。同时，由于 Complex to Mag模块输出的信号采样率为 64K，所以需要通过RationalResampler 模块改变它的输出信号采样率。设置参数 decimate 为 4， interpolate 为3，即采样率为 64K/4*3=48K。 （2）执行该流程图并不能听到真正的 AM 信号，只有”滋滋”的电流声，这是因为输入扬声器的信号功率太大。 加入衰减器 Multiply Const，同时为了能够灵活地调整输入扬声器信号功率，加入 WX GUI Slider模块这个模块的功能像一个滑块，可以灵活地调整变量的值，以便能够调试到合适的参数并收听到 AM 信号， 如图 9 所示。（1）执行该流程，并调整 volume 到 30m 左右，可以听到不是很清楚的声音。这是因为该波段的信号混有噪音，后续会继续进行处理得到清晰的声音。 观察图中的信号可以看到在 80KHz+710KHz 的波段有很强的信号，因此去解调此处的信号为了解调 790KHz 处的信号，需要将其频移至 0 频附近。要想得到该信号，可以通过乘以一个余弦信号进行频谱的搬移。修改频谱后如图 10 所示： （1）时域信号相乘相当于频域的相加。因此乘以-80KHz 的余弦波可以将信号往左搬移 80KHz。 为什么可以这样操作？ 原理为三角函数里面的和差化积公式 （2）可以增加一个 WX GUI Slider 去调节所加信号的频率，实现的对电台（频率）的可选择性。 （3）执行该流程图可以听到比较清新的声音，但仍有很多杂音，这是由于电噪声的影响。可以通过增益自动调节模块（AGC）来进行调节。 增加自动增益控制模块（AGC2）及调节频率的 slider 模块，得到如图所示的结果（1） AGC2 模块加到 Low pass filter 和 Complex to Mag 模块之间 （2） AGC2 模块参数设置： Attack=6.25e-4, Decay=1e-5。其他默认 （3）声卡可接收的功率范围是-1.0 到 1.0 （4）执行流程图，调整余弦信号频率到-80KHz，可以听到比较清晰的声音，然后调节 volume，可以增大音量。这时听到的声音比前面的要清新多了。 （5）当所观测的 FFT GUI 界面有两个以上时，可以用 WX GUI Notebook 模块。该模块可以产生如图中所示的 tab1 tab2 tab3 标签样式。 可以很清晰的听出原文是一段英文 电台文件下载]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之ASK信号的调制与解调]]></title>
    <url>%2F2019%2F04%2F23%2FGnuradio%E4%B9%8BASK%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B0%83%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%B0%83%2F</url>
    <content type="text"><![CDATA[实验目的​ 学习 GNU Radio 流程图编程。 了解 ASK 信号的发送和接收处理流程， 找到自己需要的模块， 修改模块的参数，设计 ASK 信号发送接收流程图 实验步骤​ 利用幅度键控 ASK 理论，在 GNU Radio 环境下完成了 ASK 调制信号的产生和解调。整个流图如下： ​ 第一个相乘器后产生的即 ask 信号，利用高频载波与调制信号相乘产生，其中调制信号中设置了高斯白噪声。经过传输特性为带通的信道传输。解调电路采用相干解调，由 ask 信号与原来的载波进行相乘，然后经过低通滤波，这里的门限值分别为0.1 和 0.5，不同的值对最后的影响主要是占空比和时延。最后由脉冲抽样电路完成原来数字调制信号的恢复。 原始调制信号 产生的 ask 信号波形和频谱 经过低通滤波器后的波形与频谱 最后解调的结果 与原始信号对比，为什么有延迟和占空比的变化？ 因为信号经过低通滤波器，滤波器的门限值影响延迟和占空比]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gnuradio之AM-DSB-LSB实现]]></title>
    <url>%2F2019%2F04%2F23%2FGnuradio%E4%B9%8BAM-DSB-LSB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实验目的利用模拟幅度调制理论知识和 GNURadio 流图设计方法，独立搭建模拟幅度调制设计方案，实现： AM 调制和控制调幅指数 DSB 调制和解调 LSB 调制和解调 并通过仿真结果验证其频谱的正确性。 实验原理通过控制载波、设置合理的滤波器，来观察幅度调制信号的频谱变化情况。 实验步骤可能使用的模块有”Signal Source、 Multiply Const（乘以常系数）、Add Const（加常系数） 、 Multiply、 Throttle、 WX GUI FFT Sink、 Low Pass Filter、 WX GUI Scope Sink”。 余弦调制信号频率： 200Hz； 载频： 1000Hz； 采样率； 5000Hz 放大系数 Ac： 0.35 AM 调制和控制调幅指数1.产生常规 AM 调制信号，观察频谱变化；利用 Slider 模块，调整调幅指数，观察时域波形变化。 根据公式画出上图，m(t)信号先加常系数1，再与载频信号相乘，再乘slider模块控制的常系数，最后画出时域图(频域图) DSB 调制与解调 解调 DSB 信号： 发送信号频谱： DSB 调制信号频谱： 解调后信号频谱： LSB 调制与解调$$S_{\text{SSB}}\left( t \right) = \frac{1}{2}A_{c}m\left( t \right)cos2\pi f_{c}t \mp \frac{1}{2}A_{c}m\hat{}\left( t \right)sin2\pi f_{c}t$$ 在本实验中，信号源为$m\left( t \right) = \cos\left( 2pi200*t \right)$ 其希尔伯特变换为$m\hat{}(t) = sin(2pi200*t)$ 按下图产生下边带信号 解调LSB信号： LSB 调制信号频谱： 解调信号频谱： AM文件下载DSB文件下载LSB文件下载]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>Gnuradio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4G-LTE测试分析]]></title>
    <url>%2F2019%2F04%2F19%2F4G-LTE%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[[LTEInspector: A Systematic Approach for Adversarial Testing of 4G LTE]The Attack Focus On: A-4 Authentication Relay Attack ​ 4G在我们的印象中是一个非常安全的协议，包括即将进入商用阶段的5G协议应该会更加的安全。但是实际情况的并不是如此，普渡大学的几位研究人员发现了4G协议依旧存在着很多的漏洞（已经发现了十个漏洞，其中的七个漏洞已经被验证，一个部分被验证，还有两个等待验证），部分漏洞对5G协议而言依旧是存在的。3GPP曾经讨论过在5G引入证书体系，防止手机连接恶意节点。就是说恶意节点发出的广播消息都要携带签名，手机终端能识别出来哪些是恶意节点，于是就不会尝试连接，连初始连接的第一条消息都不会发出。但是大部分运营商和设备厂商都认为这个方案太”重”了，没有采用，可能6G的时候还会再讨论。 ​ 在这次发布的十个漏洞中，有六个漏洞可以归结为拒绝服务攻击（A-1、A-3、P-1、P-2、P-4、P-5），DoS 类攻击，是长期无法解决的问题，即使在5G系统中，仍然有一些不能解决。在这篇研究报告中研究人员为我们介绍了十种4G LTE的漏洞，这些漏洞分别是基于4G LTE三个工作阶段而发现的：连接环节、寻呼环节和分离环节。而在这其中，连接环节无疑是相对复杂与重要的一个环节。 I.LTE预备​ 在论文中，作者为了方便解释他们的工作成果，将LTE网路架构进行了简化：只关注它有关附着、去附着和寻呼过程的部分。为了更好理解鉴权中继攻击的过程，我们首先学习了作者简化过的 4G LTE，并摘取其中与我们讨论相关的内容： Part One.LTE网络架构 ​ LTE网络大体上由以下三部分组成：蜂窝网络设备（也被称作用户设备或者UE）；无线电接入网（E-UTRAN）；核心网络（EPC）。 UE：UE是装备了用户身份识别卡（SIM卡）的蜂窝网络设备。SIM卡安全地储存了国际移动用户识别码（IMSI），还有用于UE和EPC通信初始化时注册和鉴权的密钥。UE本身也有唯一的设备身份：国际移动设备识别码（IMEI），它也用来注册。暴漏 IMSI/IMEI后，UE有可能被非法追踪或假冒，所以说它们是非常敏感的信息。EPC：EPC 中有两个与我们讨论内容相关的实体：MME 和 HSS。 ⑴ Mobility Management Entity: MME 管理一个跟踪区（它由一组六边形的小区构成）中的UE的附着（包括鉴权和密钥协商）,寻呼和去附着过程。它还负责记录其跟踪区中UE的位置，方便寻呼过程。 ⑵ Home Subscriber Server：HSS 储存各 UE 的 IMSI/IMEI、用户信息（如 QoS 文件）和主密钥。它会用UE的主密钥产生鉴权挑战和对称会话密钥。 Part Two.附着过程 ​ 当一个UE想要连接EPC时（比如说在它重启之后），它首先搜索附近 eNB 广播的系统信息块 (SIB) 之后，UE 会和收到的信号功率最高的 eNB 建立连接。在后文我们会讲到，这一特点能被鉴权中继攻击利用。一旦 UE 与 eNB 建立好连接，附着过程就可以根据以下步骤进行： A.注册：附着过程的第一步，是 UE 通过 eNB 向 MME 发送 attach_request 。attach_request 中用明文包含了 UE 的身份（IMSI/IMEI）和它的安全能力(比如它支持的密码算法套件）。 B.鉴权：MME 在收到 UE 的注册请求后，向用户的 HSS 发送其 IMSI，请求对该用户身份进行认证，HSS会给MME回复 authentication_challenge。之后，MME给UE发送包含 authentication_challenge 的 authentication_request。UE在收到鉴权请求后，用它的主密钥来解 authentication_challenge，并回复authentication\response 给 MME。只有鉴权过程成功了，UE 和 MME 才能进入能下一阶段。 C.安全算法协商:在注册过程中，UE 发送的 attach_request 包含了它的安全能力，于是 MME 能够挑选一对 UE 支持的加密算法和完整性保护算法。首先，MME 发送完整性保护的 security_mode_command 给 UE，其中重放了之前 UE 发来的安全能力,这是为了让 UE 验证 security_mode_command 中的安全能力是否与其发送的attach_request 中的一致。成功验证包含在 security_mode_command 中的消息认证码（MAC）后，UE 回复经过加密并有完整性保护的 security_mode_complete 给MME。至此，UE 和 MME 成功创建了保护未来通信机密和完整性的共享安全上下文，即共享密钥。 D.安全临时标识符交换：MME 向 UE 发送一条经加密且有完整性保护的attach_accept，其中包含了一个临时标识，即 GUTI(Globally Unique Temporary Identity)，用于此后的所有的 UE 与 eNB/MME 之间的通信。其目的是为了减少IMSI/IMEI 泄露的可能。收到这条信息后，UE 回复 attach_complete，结束附着过程。附着完成后，UE 和 eNB 之间也会产生一对共享密钥，给它们之间的通信创建安全上下文。 上面大致介绍了 4G 工作过程中的附着阶段，在这里我们可以对这三个过程做一个总结：第一个环节是连接环节，也就是将用户设备与网络相关联的过程（例如，用户打开手机）；第二个环节是寻呼环节，该环节是建立呼叫的一部分，通常用于强制设备重新获取系统信息，并用于紧急警报；最后一个环节是分离环节，用户关闭设备，网络会与设备断开连接的过程（又如，由于信号质量差无法进行网络验证）。 II.鉴权中继攻击​ 在了解了这十种攻击之后，发现其中的两种攻击最有研究价值：其中的一个攻击是 A-4 鉴权中继攻击，这种手法可以伪造手机在网络中的位置（这个是可以被个人利用的），相当于手机与真实网络中间加了两个中继器，真实网络只知道中继器在哪里，不知道手机在哪里。这样，即使该用户在西安也可以将位置信息变成北京，形成完美的不在场证明；剩下的一种攻击是P-3发送假的灾害警报，例如18年1月份的时候夏威夷有一个虚假导弹袭击的警报，就是基于这种原理实现的。 i.攻击过程描述 实施鉴权中继攻击中，可以分为以下两个步骤：I. 断开受害者设备 $\text{UE}{\text{vic}}$ 与核心网EPC之间的连接；II.攻击者设备 $\text{UE}{\text{adv}}$ 伪装成受害者设备 $UE_{\text{vic}}$ 接入到核心网EPC中。 为了断开受害者设备 $\text{UE}_{\text{vic}}$ 与核心网 EPC 之间的连接，可以利用研究人发现的其他漏洞来达成这一目标。例如 D-1 降级攻击就可以完成此步骤，在假设中攻击者知道了受害者设备的 IMSI，所以为了能够精准的攻击，攻击者会通过恶意的 eNodeB广播发送 identity_request，UE 实体收到此条消息后，会向 eNodeB 回复包含自己的 IMSI 的 identity_response。此时，如果受害者刚好在其中的话，那么攻击者就可以向该受害者设备 $\text{UE}_{\text{vic}}$ 发送 detach_request，至此完成了中继攻击的第一个步骤。 受害者设备 $\text{UE}{\text{vic}}$ 这时会尝试着与信号最强的 eNodeB 建立连接—此时的信号最强的 eNodeB 是 ${eN\text{ode}B}{\text{adv}}$，受害者终端 $E_{\text{vic}}$ 会向 ${eN\text{ode}B}_{\text{adv}}$ 发送附着请求(attach_request) 的消息 $m_{\text{re}}$，接着 ${eN\text{ode}B}{\text{adv}}$ 会将此附着请求消息 $m{\text{re}}$ 转发给攻击者设备 $\text{UE}{\text{adv}}$，由 $\text{UE}{\text{adv}}$ 将 $m_{\text{re}}$ 向正常节点 ${eN\text{ode}B}{\text{ben}\text{gin}}$ 转发。当合法的 MME 收到连接请求 $m{\text{re}}$后，就会通过正常节点 ${eN\text{ode}B}{\text{ben}\text{gin}}$ 向攻击者设备发送认证挑战 c。当然，攻击者设备是没有能力去解决这个认证挑战,它会通过恶意的节点${eN\text{ode}B}{\text{adv}}$ 将此认证挑战 c 转发给受害者设备 $\text{UE}{\text{vic}}$。受害者设备 $\text{UE}{\text{vic}}$ 收到认证挑战 c 后，它并没有意识到整个过程中发生了什么，它以为这是一个正常的节点发送过来的挑战 c，因此它会将挑战 c 解开，将结果 r 发送给恶意的节点 ${eN\text{ode}B}{\text{adv}}$，和刚开始的附着请求的消息过程一致，恶意的节点 ${eN\text{ode}B}{\text{adv}}$会将结果 r 转发给恶意设备 $\text{UE}{\text{adv}}$，由恶意设备$\text{UE}{\text{adv}}$将结果 r 提交给节点 ${eN\text{ode}B}_{\text{ben}\text{gin}}$，由该节点将结果r发送给 MME。对于附着过程中的剩下步骤，使用和上面请求认证和验证挑战两步一样的原理，攻击者设备就可以冒充并使用另一方的身份接上网络。 ii.攻击原理 鉴权中继攻击，只能伪造手机的位置，手机的完整性保护和加密保护仍然是没有攻破的，中继器不能解出手机发送的数据内容（除非运行商公然忽视了安全标准的推荐，选择在连接建立阶段使用若安全性或者是无安全性文本传输）。在中继攻击中，破坏的是信息传输的认证性，因为在正常设备和正常节点的信息通路中，加入了一个恶意节点和恶意设备，正常设备不知道自己收到的信息是恶意节点转发的，同理，正常节点也不知道自己收到的信息是恶意设备转发正常设备的。 iii.攻击可能带来的影响 在研究人员的论文中，他们还提到了鉴权中继攻击会带来的影响。因为恶意设备和节点会将受害者设备的一切发送与接受的信息进行转发，所以攻击者可以对受害者发动拒绝服务攻击（例如，将受害者的文件传输、电话等信息不进行转发，因此受害者此部分的服务因此就不能实现了）。同样地， 攻击者可以根据转发的数据大致的勾勒出受害者使用的习惯、模式等隐私信息。最重要的是，这种方法可以伪造手机在网络中的位置。因为攻击者设备$\text{UE}{\text{adv}}$无需和受害者设备$\text{UE}{\text{vic}}$在同一片追踪区域，因此$\text{UE}{\text{adv}}$可以从另外的区域向核心网 EPC鉴定自己，由此受害者设备$\text{UE}{\text{vic}}$的位置信息历史也会受到误导(在核心网EPC那边来看，真正连入的设备只有$\text{UE}{\text{vic}}$，会存储有关的信息，例如：$\text{UE}{\text{vic}}$的 IMSI、IMEI 等信息，而$\text{UE}{\text{adv}}$发送的位置信息因此也会被误认为是$\text{UE}{\text{vic}}$的位置信息)。 III.其他攻击 在鉴权中继攻击中，第一步需要实施的工作是将受害者设备$\text{UE}_{\text{vic}}$与核心网核心网EPC断开连接，论文中，研究人员给我们介绍了三种攻击可以作为鉴权中继攻击的前奏。 i.A-3 麻木攻击 麻木攻击可使攻击者注入乱序控制层协议消息，中断受害用户手机服务，只有重启手机才能恢复。该攻击可与其他攻击联合使用，让攻击者能够冒充受害者行骗。从攻击的性质上来说，麻木攻击是一种拒绝服务攻击。 根据协议标准，网间传递的消息 auth_reject 不受加密保护，因此一旦受害设备UE连接到恶意节点 eNodeB，恶意节点就可以向受害设备注入拒绝验证消息auth_reject。受害设备 UE 一接收到 auth_reject 消息后，它首先会将自己从网络中去附着，完全关闭所有蜂窝活动，甚至不尝试降级或者连接到 3G / 2G 网络。 这种情况下，即使重新插入 SIM 卡也不允许受害者 UE 重新与核心网 EPC 连接。而为了能够重新接入网络，受害者必须将他的设备 UE 重新启动方可。 ii.P-2 隐身开启攻击 在劫持受害者 UE 寻呼信道后，恶意节点可以创建一条寻呼信息，其中一条寻呼记录由受害者 UE 的 IMSI 组成，寻呼记录的其他字段设置为与原始寻呼信息类似。接收到带有 IMSI 的寻呼信息后，受害者 UE 发现它自己的 IMSI 在第一个寻呼记录中。所以，它会将自己从核心分组网中断开，然后发送请求附着的消息。这种攻击会使得受害手机断开与 EPC 的连接，所以可以将这种攻击作为鉴权中继攻击的前奏之一。 iii.D-1 去附着/降级攻击 降级攻击的过程和麻木攻击的过程是十分类似的，攻击者可以在网络中向某一受害者 UE 注入消息 detach_request，可以强制该受害者 UE 从网络中断开。 此外，为了实施这种攻击，需要知道受害者 UE 的 IMSI。因此，研究人员在报告中说到，可以先通过恶意节点 eNodeB 广播消息 identity_request， UE 收到后会回复包含自身 IMSI 的消息 identity_response 给恶意节点，攻击者就可以得到 UE 的 IMSI。 IV.参考论文与链接[1] Syed Rafiul Hussain，Omar Ch-wdhury，Shagufta Mehnaz, Elisa Ber-Tino,” LTEInspector: A Systematic Approach for Adversarial Testing of 4G LTE”,Feb .2018 [2] “对LTE Inspector论文的一些解读”，https://unicorn.360.com/blog/2018/03/09/Interpretation_of_LTE_Inspector_Papers [3] “研究人员发现4G LTE网络协议漏洞”， https://www.freebuf.com/news/164109.html [4] “从追踪到劫持 研究人员发现十个 4G LTE 漏洞”, https://www.aqniu.com/hack-geek/31968.html]]></content>
      <categories>
        <category>无线通信</category>
      </categories>
      <tags>
        <tag>无线网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop部署]]></title>
    <url>%2F2019%2F04%2F13%2FHadoop%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[环境Ubuntu 14.04.5 x64Hadoop 2.x.y Hadoop 有两个主要版本，Hadoop 1.x.y 和 Hadoop 2.x.y 系列，比较老的教材上用的可能是 0.20 这样的版本。Hadoop 2.x 版本在不断更新，本教程均可适用。如果需安装 0.20，1.2.1这样的版本，也可以作为参考，主要差别在于配置项 创建Hadoop用户(创建新用户是为了改环境的时候更方便一点)ctrl+alt+t打开终端 命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shellsudo useradd -m hadoop -s /bin/bash 设置密码sudo passwd hadoop 部署管理员权限sudo adduser hadoop sudo su hadoop切换用户 更新一下aptsudo apt-get update //sudo apt-get install vim 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：sudo apt-get install openssh-server ssh localhost 首次登录提示输入yes看到hadoop@hadoop-Practise：即可确定登录成功 exit退出用ssh-keygen生成密钥 1234exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 在 Linux 系统中，~ 代表的是用户的主文件夹，即 “/home/用户名” 这个目录，如用户名为 hadoop，则 ~ 代表 “/home/hadoop/ 此时ssh localhost命令无需密码即可登录 安装Java环境sudo apt-get install openjdk-7-jre openjdk-7-jdkJava环境可选择 Oracle 的 JDK，或是 OpenJDK，OpenJDK 1.7 是没问题的。为方便，这边直接通过命令安装 OpenJDK 7（http://wiki.apache.org/hadoop/HadoopJavaVersions ） 安装好 OpenJDK 后，需要找到相应的安装路径，这个路径是用于配置JAVA_HOME 环境变量的。执行如下命令：dpkg -L openjdk-7-jdk | grep ‘/bin/javac’ 该命令会输出一个路径，除去路径末尾的 “/bin/javac”，剩下的就是正确的路径了。如输出路径为 /usr/lib/jvm/java-7-openjdk-amd64/bin/javac，则我们需要的路径为 /usr/lib/jvm/java-7-openjdk-amd64。 接着配置 JAVA_HOME 环境变量，为方便，我们在 ~/.bashrc 中进行设置vim ~/.bashrc source ~/.bashrc #使变量设置生效 echo $JAVA_HOME # 检验变量值 java -version $JAVA_HOME/bin/java -version # 与直接执行 java -version 一样 如果设置正确的话，$JAVA_HOME/bin/java -version 会输出 java 的版本信息，且和 java -version 的输出结果一样则Hadoop 所需的 Java 环境安装完成 安装 Hadoop 2（）在root用户的/usr/local/目录下下载hadoop-2.6.0.tar.gz文件wget https://archive.apache.org/dist/hadoop/core/hadoop-2.6.0/hadoop-2.6.0.tar.gz tar hadoop-2.6.0.tar.gz 解压安装包mv hadoop-2.6.0 hadoop 将安装目录由hadoop-2.6.0改为hadoop chown -R hadoop hadoop 将hadoop目录的拥有者设为hadoop用户-R : 对目前目录下的所有文件与子目录进行相同的拥有者变更(即以递回的方式逐个变更) 虽然Hadoop安装在/usr/local中，也是针对所有用户的，但是我们用账户hadoop来进行整个测试，所以更改文件权限不能不做，否则，在后面./sbin/start-dfs.sh步会遇到no such file or directory等错误 使用如下命令查看是否安装成功cd /usr/local/hadoop./bin/hadoop version 至此，hadoop安装成功 单机模式Hadoop本地模式只是用于本地开发调试，或者快速安装体验Hadoop 打开/usr/local/hadoop/etc/hadoop/hadoop-env.sh 将export JAVAHOME=${JAVAHOME}修改为export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64#视Java安装位置而定 (java的安装路径可用echo $JAVA_HOME查询) export HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:/usr/local/hadoop/bin 然后source hadoop-env.sh以保存修改此时单机模式就已配置完成。 单机模式测试采用Hadoop自带的示例WordCount来测试单机模式是否安装成功在/usr/local/hadoop路径下创input目录然后将README.txt文件拷贝到input目录中，然后执行 1bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.7.3-sources.jar org.apache.hadoop.examples.WordCount input output 输出结果如下： 即可说明单机模式配置成功！ 打开output目录下的part 00000文件可以看到每个词的出现次数，实现了词频统计 伪分布式模式学习Hadoop一般是在伪分布式模式下进行。这种模式是在一台机器上各个进程上运行Hadoop的各个模块，伪分布式的意思是虽然各个模块是在各个进程上分开运行的，但是只是运行在一个操作系统上的，并不是真正的分布式。 沿用单机模式的配置，再修改core-site.xml和hafs-site.xml两个文件vim /usr/local/hadoop/etc/hadoop/core-site.xml原本文件中是如下内容 添加成如下内容： hadoop.tmp.dir file:/usr/local/hadoop/tmp Abase for other temporary directories. fs.defaultFS hdfs://localhost:9000 vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml添加成如下内容： dfs.replication 1 dfs.namenode.name.dir file:/usr/local/hadoop/tmp/dfs/name dfs.datanode.data.dir file:/usr/local/hadoop/tmp/dfs/data 注意，如果要变回单机模式，清空&lt;configuration&gt;标签中的内容即可。 且如果不是以YARN模式启动的话，无需配置mapred-site.xml。 格式化 namenode 在/usr/local/hadoop目录下以hadoop用户执行./bin/hdfs namenode -format 如上说明格式化namenode成功 ./sbin/start-dfs.sh 启动服务可以看到 用jps命令判断是否启动成功 如上，启动成功！ 若无Datanode和Namenode,说明配置不成功，针对这种情况，依次执行一下命令 1234./sbin/stop-dfs.sh # 关闭dfsrm -r ./tmp # 删除 tmp 文件，注意这会删除 HDFS 中原有的所有数据./bin/hdfs namenode -format # 重新格式化 NameNode./sbin/start-dfs.sh # 重启dfs 若 jps 命令’command not found’ ，由于jps是jdk自带的命令，找不到命令可能环境变量出了问题，用echo $PATH 查看环境变量，若无，则在hadoop用户的根目录下的./bashrc文件中配置JAVA的环境变量 export JAVA_HOME=/java的安装路径/export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH 然后source ./bashrc 保存应用即可 启动成功后可以打开http://localhost:50070管理页面查看namenode和datanode或者DFS信息（云服务器可以打开http://服务器地址:50070/） 伪分布模式测试单机模式直接读取的是本地文件，如input目录和output目录，而伪分布式模式需要读取分布式文件系统HDFS中的文件，所以还得先建立HDFS。 ./bin/hdfs dfs -mkdir -p /user/hadoop # 在HDFS中创建用户目录./bin/hdfs dfs -mkdir input # 在用户目录下创建input目录./bin/hdfs dfs -put ./etc/hadoop/*.xml input # 将一些测试文件移入input目录，就移配置xml文件作为输入 （相对路径input即可表示/user/hadoop/input） 然后执行一个筛出dfs开头的单词的程序： 其中./bin/hadoop jar向集群提交作业 grep是Hadoop提供的一个示例程序 ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output ‘dfs[a-z.]+’ 查看输出，此时输出仍在HDFS中 可以将HDFS中的文件拷到本地./bin/hdfs dfs -get output ./output 注意第二次运行的时候需要删除HDFS中的output，否则会报错，因为此中有防止覆盖的机制，不会在你在不知情的情况下就覆盖掉上一个output。 最后所有程序运行结束后运行./sbin/stop-dfs.sh停止守护进程即可 wordcount测试 先删除HDFS中的output目录：./bin/hdfs dfs -rm -r output 然后如同单机模式中运行WordCount程序一样，运行：bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar org.apache.hadoop.examples.WordCount input output 完全分布模式完全分布式模式才是生产环境采用的模式，Hadoop运行在服务器集群上，生产环境一般都会做HA，以实现高可用 HA安装HA是指高可用，为了解决Hadoop单点故障问题，生产环境一般都做HA部署。]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
